# Bitácora 002 - 18/10/2025

## Plan de Trabajo: Backend API REST - Desarrollo Incremental

---

## Principios Fundamentales del Plan

1. ✅ **Desarrollo vertical por feature** (frontend + backend juntos)
2. ✅ **Testing manual/automático después de cada incremento**
3. ✅ **No avanzar sin validar integración**
4. ✅ **Despliegue continuo en ambiente de desarrollo**
5. ✅ **Cada incremento debe ser funcional y demostrable**

---

## Decisiones Técnicas

### Framework Backend: **Laravel 11**

#### Justificación:
- **Eloquent ORM**: Relaciones entre tablas elegantes (User → GameSessions → Shots)
- **Laravel Sanctum**: Autenticación API profesional
- **Migraciones**: Control de versiones de base de datos
- **Testing integrado**: PHPUnit para garantizar calidad
- **Ecosistema rico**: Paquetes para OAuth, estadísticas, reportes
- **Escalabilidad**: Preparado para crecimiento futuro
- **API Resources**: Transformación de datos JSON elegante

### Librería HTTP Frontend: **Axios**

#### Justificación:
- Interceptors para autenticación global
- Sintaxis más limpia que fetch
- Manejo de errores centralizado
- TypeScript-friendly
- Configuración de baseURL

**Instalación:**
```bash
npm install axios
```

---

## Diseño de Base de Datos

### Modelo Entidad-Relación

```
┌─────────────────────────┐
│       users             │
├─────────────────────────┤
│ id (PK)                 │
│ google_id (UNIQUE)      │
│ email                   │
│ name                    │
│ picture                 │
│ profile (ENUM)          │ ← NUEVO
│ created_at              │
│ updated_at              │
└─────────────────────────┘
         │ 1
         │
         ├─────────────────────┐
         │ N                   │ N
         │                     │
┌────────▼─────────────┐  ┌────▼──────────────┐
│   user_logins        │  │  game_sessions    │
├──────────────────────┤  ├───────────────────┤
│ id (PK)              │  │ id (PK)           │
│ user_id (FK)         │  │ user_id (FK)      │
│ logged_in_at         │  │ started_at        │
│ ip_address           │  │ finished_at       │
│ user_agent           │  │ final_score       │
│ created_at           │  │ max_level_reached │
└──────────────────────┘  │ duration_seconds  │
                          │ created_at        │
                          │ updated_at        │
                          └───────────────────┘
                                   │ 1
                                   │
                                   │ N
                          ┌────────▼──────────┐
                          │      shots        │
                          ├───────────────────┤
                          │ id (PK)           │
                          │ game_session_id   │
                          │ shot_at           │
                          │ coordinate_x      │
                          │ coordinate_y      │
                          │ factor_1          │
                          │ factor_2          │
                          │ correct_answer    │
                          │ card_value        │
                          │ is_correct        │
                          │ created_at        │
                          │ updated_at        │
                          └───────────────────┘
```

---

## Descripción de Tablas

### Tabla: `users`
Almacena información básica del usuario autenticado con Google OAuth.

| Campo | Tipo | Descripción |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `google_id` | VARCHAR(255) UNIQUE | ID del usuario en Google |
| `email` | VARCHAR(255) | Email del usuario |
| `name` | VARCHAR(255) | Nombre completo |
| `picture` | TEXT | URL de la foto de perfil de Google |
| `profile` | ENUM('student', 'teacher', 'admin') | Tipo de usuario |
| `created_at` | TIMESTAMP | Fecha de registro |
| `updated_at` | TIMESTAMP | Última actualización |

**Índices:**
- PRIMARY KEY: `id`
- UNIQUE: `google_id`
- INDEX: `email`
- INDEX: `profile`

**Valores de `profile`:**
- `student` (por defecto): Puede jugar y ver sus propias estadísticas
- `teacher`: Puede ver estadísticas de estudiantes asignados
- `admin`: Acceso total al sistema

---

### Tabla: `user_logins` ⭐ NUEVA
Registra cada inicio de sesión del usuario para auditoría y análisis.

| Campo | Tipo | Descripción |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `user_id` | BIGINT UNSIGNED | FK a tabla users |
| `logged_in_at` | TIMESTAMP | Timestamp del login |
| `ip_address` | VARCHAR(45) NULL | Dirección IP (IPv4/IPv6) |
| `user_agent` | TEXT NULL | Navegador/dispositivo usado |
| `created_at` | TIMESTAMP | Fecha de creación del registro |

**Índices:**
- PRIMARY KEY: `id`
- FOREIGN KEY: `user_id` REFERENCES `users(id)` ON DELETE CASCADE
- INDEX: `user_id, logged_in_at` (para consultas de historial)

**Propósito:**
- Auditoría de accesos al sistema
- Análisis de frecuencia de uso
- Detección de patrones de uso
- Seguridad (detección de logins sospechosos)

---

### Tabla: `game_sessions`
Representa una sesión de juego de 5 minutos.

| Campo | Tipo | Descripción |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `user_id` | BIGINT UNSIGNED | FK a tabla users |
| `started_at` | TIMESTAMP | Hora de inicio de la sesión |
| `finished_at` | TIMESTAMP NULL | Hora de finalización (null si en curso) |
| `final_score` | INTEGER | Puntaje final obtenido |
| `max_level_reached` | INTEGER | Nivel máximo alcanzado |
| `duration_seconds` | INTEGER | Duración real de la sesión |
| `created_at` | TIMESTAMP | Fecha de creación del registro |
| `updated_at` | TIMESTAMP | Última actualización |

**Índices:**
- PRIMARY KEY: `id`
- FOREIGN KEY: `user_id` REFERENCES `users(id)` ON DELETE CASCADE
- INDEX: `user_id, started_at` (para consultas de historial)
- INDEX: `finished_at` (para filtrar sesiones activas/finalizadas)

---

### Tabla: `shots`
Registra cada disparo que impacta un card (correcto o incorrecto).

| Campo | Tipo | Descripción |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `game_session_id` | BIGINT UNSIGNED | FK a tabla game_sessions |
| `shot_at` | TIMESTAMP(3) | Timestamp con milisegundos del disparo |
| `coordinate_x` | DECIMAL(8,2) | Coordenada X del disparo (0-1200) |
| `coordinate_y` | DECIMAL(8,2) | Coordenada Y del disparo (0-800) |
| `factor_1` | INTEGER | Primer factor de la multiplicación |
| `factor_2` | INTEGER | Segundo factor de la multiplicación |
| `correct_answer` | INTEGER | Respuesta correcta de la multiplicación |
| `card_value` | INTEGER | Valor del card impactado |
| `is_correct` | BOOLEAN | true si acertó, false si erró |
| `created_at` | TIMESTAMP | Fecha de creación del registro |
| `updated_at` | TIMESTAMP | Última actualización |

**Índices:**
- PRIMARY KEY: `id`
- FOREIGN KEY: `game_session_id` REFERENCES `game_sessions(id)` ON DELETE CASCADE
- INDEX: `game_session_id` (para consultas por sesión)
- INDEX: `is_correct` (para estadísticas de precisión)
- INDEX: `factor_1, factor_2` (para estadísticas por tabla)

---

## Endpoints de la API

### Autenticación
```
POST   /api/auth/verify              - Verificar token de Google y registrar login
```

### Sesiones de Juego
```
POST   /api/sessions                 - Crear nueva sesión de juego
PUT    /api/sessions/{id}/finish     - Finalizar sesión y guardar puntaje
GET    /api/sessions                 - Listar sesiones del usuario (paginado)
GET    /api/sessions/{id}            - Detalle de sesión específica + disparos
```

### Disparos
```
POST   /api/sessions/{id}/shots      - Registrar disparo que impacta card
```

### Estadísticas
```
GET    /api/stats/user               - Estadísticas generales del usuario
GET    /api/stats/tables             - Desempeño por tabla de multiplicar
GET    /api/stats/progress           - Progreso histórico (últimas 10 sesiones)
```

### Administración (solo admin)
```
GET    /api/admin/users              - Listar todos los usuarios
PUT    /api/admin/users/{id}/profile - Cambiar rol de usuario
GET    /api/admin/stats/global       - Estadísticas globales del sistema
```

---

## Incrementos de Desarrollo

### ✅ INCREMENTO 1: Autenticación Completa
**Duración estimada:** 6 horas
**Objetivo:** Usuario puede loguearse con Google OAuth y quedar registrado en la base de datos

#### Backend (2-3 horas)

**Setup inicial:**
```bash
cd ~/proyectos/web-javascript-react/mulitplication-shooter/multiplicacion-shooter-backend
composer create-project laravel/laravel .
composer require google/apiclient
```

**Tareas:**
1. Configurar `.env`:
   ```env
   DB_CONNECTION=mysql
   DB_HOST=127.0.0.1
   DB_PORT=3306
   DB_DATABASE=multiplication_shooter
   DB_USERNAME=root
   DB_PASSWORD=

   GOOGLE_CLIENT_ID=tu_client_id_aqui
   ```

2. Configurar CORS en `config/cors.php`:
   ```php
   'paths' => ['api/*'],
   'allowed_origins' => ['http://localhost:5173'],
   'allowed_methods' => ['*'],
   'allowed_headers' => ['*'],
   'exposed_headers' => [],
   'max_age' => 0,
   'supports_credentials' => true,
   ```

3. Crear migraciones:
   ```bash
   php artisan make:migration create_users_table
   php artisan make:migration create_user_logins_table
   ```

4. Definir migraciones:

   **Migration: users**
   ```php
   Schema::create('users', function (Blueprint $table) {
       $table->id();
       $table->string('google_id')->unique();
       $table->string('email');
       $table->string('name');
       $table->text('picture')->nullable();
       $table->enum('profile', ['student', 'teacher', 'admin'])->default('student');
       $table->timestamps();

       $table->index('email');
       $table->index('profile');
   });
   ```

   **Migration: user_logins**
   ```php
   Schema::create('user_logins', function (Blueprint $table) {
       $table->id();
       $table->foreignId('user_id')->constrained()->onDelete('cascade');
       $table->timestamp('logged_in_at');
       $table->string('ip_address', 45)->nullable();
       $table->text('user_agent')->nullable();
       $table->timestamps();

       $table->index(['user_id', 'logged_in_at']);
   });
   ```

5. Ejecutar migraciones:
   ```bash
   php artisan migrate
   ```

6. Crear modelos:
   ```bash
   php artisan make:model User
   php artisan make:model UserLogin
   ```

7. Definir modelo `User`:
   ```php
   class User extends Model
   {
       const PROFILE_STUDENT = 'student';
       const PROFILE_TEACHER = 'teacher';
       const PROFILE_ADMIN = 'admin';

       protected $fillable = [
           'google_id', 'email', 'name', 'picture', 'profile'
       ];

       public function logins()
       {
           return $this->hasMany(UserLogin::class);
       }

       public function isAdmin(): bool
       {
           return $this->profile === self::PROFILE_ADMIN;
       }
   }
   ```

8. Definir modelo `UserLogin`:
   ```php
   class UserLogin extends Model
   {
       protected $fillable = [
           'user_id', 'logged_in_at', 'ip_address', 'user_agent'
       ];

       protected $casts = [
           'logged_in_at' => 'datetime',
       ];

       public function user()
       {
           return $this->belongsTo(User::class);
       }
   }
   ```

9. Crear servicio de autenticación:
   ```bash
   php artisan make:service GoogleAuthService
   ```

10. Crear controlador:
    ```bash
    php artisan make:controller AuthController
    ```

11. Implementar endpoint `POST /api/auth/verify`:
    ```php
    public function verify(Request $request)
    {
        $request->validate([
            'token' => 'required|string'
        ]);

        $googleUser = $this->googleAuthService->verifyToken($request->token);

        // Buscar o crear usuario
        $user = User::firstOrCreate(
            ['google_id' => $googleUser['sub']],
            [
                'email' => $googleUser['email'],
                'name' => $googleUser['name'],
                'picture' => $googleUser['picture'],
                'profile' => User::PROFILE_STUDENT
            ]
        );

        // SIEMPRE registrar login
        UserLogin::create([
            'user_id' => $user->id,
            'logged_in_at' => now(),
            'ip_address' => $request->ip(),
            'user_agent' => $request->userAgent()
        ]);

        return response()->json([
            'success' => true,
            'data' => $user
        ]);
    }
    ```

12. Definir ruta en `routes/api.php`:
    ```php
    Route::post('/auth/verify', [AuthController::class, 'verify']);
    ```

#### Frontend (2 horas)

**Tareas:**

1. Instalar Axios:
   ```bash
   cd ~/proyectos/.../multiplicacion-shooter-frontend
   npm install axios
   ```

2. Crear archivo de configuración de API:
   ```typescript
   // src/config/api.ts
   export const API_CONFIG = {
     BASE_URL: import.meta.env.VITE_API_URL || 'http://localhost:8000/api',
     TIMEOUT: 10000
   };
   ```

3. Crear servicio API base:
   ```typescript
   // src/services/apiService.ts
   import axios from 'axios';
   import { API_CONFIG } from '../config/api';

   const apiClient = axios.create({
     baseURL: API_CONFIG.BASE_URL,
     timeout: API_CONFIG.TIMEOUT,
     headers: {
       'Content-Type': 'application/json',
       'Accept': 'application/json'
     }
   });

   // Interceptor para agregar token
   apiClient.interceptors.request.use((config) => {
     const token = localStorage.getItem('google_auth_token');
     if (token) {
       config.headers.Authorization = `Bearer ${token}`;
     }
     return config;
   });

   // Interceptor para manejar errores
   apiClient.interceptors.response.use(
     (response) => response,
     (error) => {
       if (error.response?.status === 401) {
         console.error('Token inválido o expirado');
         // Redirigir a login
       }
       return Promise.reject(error);
     }
   );

   export default apiClient;
   ```

4. Crear tipos TypeScript para API:
   ```typescript
   // src/types/api.ts
   export interface ApiResponse<T> {
     success: boolean;
     data: T;
   }

   export interface UserData {
     id: number;
     google_id: string;
     email: string;
     name: string;
     picture: string;
     profile: 'student' | 'teacher' | 'admin';
     created_at: string;
   }
   ```

5. Crear servicio de autenticación:
   ```typescript
   // src/services/authApiService.ts
   import apiClient from './apiService';
   import type { ApiResponse, UserData } from '../types/api';

   export const authApiService = {
     async verifyGoogleToken(token: string): Promise<UserData> {
       const response = await apiClient.post<ApiResponse<UserData>>(
         '/auth/verify',
         { token }
       );
       return response.data.data;
     }
   };
   ```

6. Integrar en `LoginScene`:
   ```typescript
   // src/scenes/LoginScene.ts (modificar handleGoogleCallback)
   private async handleGoogleCallback(response: GoogleCredentialResponse): Promise<void> {
     console.log('Google callback received');

     try {
       // Primero procesar con AuthManager (local)
       const success = this.authManager.login(response.credential);

       if (!success) {
         throw new Error('Error al procesar login local');
       }

       // Luego enviar al backend
       const userData = await authApiService.verifyGoogleToken(response.credential);
       console.log('Usuario registrado en backend:', userData);

       // Guardar profile del usuario
       localStorage.setItem('user_profile', userData.profile);

       // Mostrar mensaje de bienvenida
       this.showWelcomeMessage(userData.name);

       // Remover botón de Google
       const buttonDiv = document.getElementById('google-signin-button');
       if (buttonDiv) {
         buttonDiv.remove();
       }

       // Transición al juego
       this.time.delayedCall(2000, () => {
         this.scene.start('GameScene');
       });

     } catch (error) {
       console.error('Error al verificar token con backend:', error);

       const errorText = this.add.text(
         this.cameras.main.centerX,
         this.cameras.main.centerY + 200,
         'Error al conectar con el servidor. Intenta de nuevo.',
         {
           fontSize: '20px',
           color: '#ff0000'
         }
       );
       errorText.setOrigin(0.5);
     }
   }
   ```

7. Actualizar `.env` del frontend:
   ```env
   VITE_API_URL=http://localhost:8000/api
   VITE_GOOGLE_CLIENT_ID=tu_client_id
   ```

#### Testing Manual (30 minutos)

**Checklist de validación:**

- [ ] **Primera vez que usuario se loguea:**
  - [ ] Se crea registro en tabla `users` con `profile='student'`
  - [ ] Se crea registro en tabla `user_logins` con timestamp actual
  - [ ] Frontend recibe datos del usuario correctamente
  - [ ] Console muestra: "Usuario registrado en backend: {datos}"

- [ ] **Segunda vez que usuario se loguea (mismo google_id):**
  - [ ] NO se duplica en tabla `users`
  - [ ] SÍ se crea nuevo registro en tabla `user_logins`
  - [ ] Frontend recibe los mismos datos del usuario
  - [ ] `ip_address` y `user_agent` se guardan correctamente

- [ ] **Verificar en base de datos:**
  - [ ] Abrir phpMyAdmin/MySQL Workbench
  - [ ] Ver tabla `users`: debe haber 1 registro
  - [ ] Ver tabla `user_logins`: debe haber N registros (uno por cada login)
  - [ ] Verificar que `user_id` en `user_logins` coincide con `id` en `users`

- [ ] **Manejo de errores:**
  - [ ] Detener servidor Laravel → Frontend muestra mensaje de error
  - [ ] Token inválido → Backend retorna 401/400

#### Testing Automático

**Crear tests en Laravel:**

```bash
php artisan make:test AuthTest
```

```php
// tests/Feature/AuthTest.php
class AuthTest extends TestCase
{
    use RefreshDatabase;

    /** @test */
    public function first_login_creates_user_and_login_record()
    {
        $response = $this->postJson('/api/auth/verify', [
            'token' => 'mock_valid_token'
        ]);

        $response->assertStatus(200);
        $this->assertDatabaseCount('users', 1);
        $this->assertDatabaseCount('user_logins', 1);
    }

    /** @test */
    public function second_login_does_not_duplicate_user()
    {
        // Primer login
        $this->postJson('/api/auth/verify', ['token' => 'mock_token']);

        // Segundo login
        $this->postJson('/api/auth/verify', ['token' => 'mock_token']);

        $this->assertDatabaseCount('users', 1);
        $this->assertDatabaseCount('user_logins', 2);
    }

    /** @test */
    public function every_login_creates_login_record()
    {
        $user = User::factory()->create();

        for ($i = 0; $i < 5; $i++) {
            $this->postJson('/api/auth/verify', ['token' => 'mock_token']);
        }

        $this->assertDatabaseCount('user_logins', 5);
    }
}
```

**Ejecutar tests:**
```bash
php artisan test --filter AuthTest
```

#### ✋ CHECKPOINT 1

**NO AVANZAR AL INCREMENTO 2 SIN VALIDAR:**
- ✅ Todos los tests automáticos pasan
- ✅ Todos los checks del testing manual están completados
- ✅ Base de datos tiene los registros esperados
- ✅ Frontend muestra datos correctamente en consola

---

### ✅ INCREMENTO 2: Crear Sesión de Juego
**Duración estimada:** 4.5 horas
**Objetivo:** Al iniciar el juego, crear una sesión en la base de datos

#### Backend (2 horas)

**Tareas:**

1. Crear migración:
   ```bash
   php artisan make:migration create_game_sessions_table
   ```

2. Definir migración:
   ```php
   Schema::create('game_sessions', function (Blueprint $table) {
       $table->id();
       $table->foreignId('user_id')->constrained()->onDelete('cascade');
       $table->timestamp('started_at');
       $table->timestamp('finished_at')->nullable();
       $table->integer('final_score')->default(0);
       $table->integer('max_level_reached')->default(1);
       $table->integer('duration_seconds')->default(0);
       $table->timestamps();

       $table->index(['user_id', 'started_at']);
       $table->index('finished_at');
   });
   ```

3. Ejecutar migración:
   ```bash
   php artisan migrate
   ```

4. Crear modelo:
   ```bash
   php artisan make:model GameSession
   ```

5. Definir modelo `GameSession`:
   ```php
   class GameSession extends Model
   {
       protected $fillable = [
           'user_id', 'started_at', 'finished_at',
           'final_score', 'max_level_reached', 'duration_seconds'
       ];

       protected $casts = [
           'started_at' => 'datetime',
           'finished_at' => 'datetime',
       ];

       public function user()
       {
           return $this->belongsTo(User::class);
       }

       public function shots()
       {
           return $this->hasMany(Shot::class);
       }

       public function isActive(): bool
       {
           return $this->finished_at === null;
       }
   }
   ```

6. Actualizar modelo `User`:
   ```php
   public function gameSessions()
   {
       return $this->hasMany(GameSession::class);
   }
   ```

7. Crear middleware de autenticación:
   ```bash
   php artisan make:middleware ValidateGoogleToken
   ```

8. Implementar middleware:
   ```php
   public function handle(Request $request, Closure $next)
   {
       $token = $request->bearerToken();

       if (!$token) {
           return response()->json(['error' => 'Token no proporcionado'], 401);
       }

       try {
           $googleUser = $this->googleAuthService->verifyToken($token);
           $user = User::where('google_id', $googleUser['sub'])->first();

           if (!$user) {
               return response()->json(['error' => 'Usuario no encontrado'], 401);
           }

           $request->merge(['authenticated_user' => $user]);
           return $next($request);

       } catch (\Exception $e) {
           return response()->json(['error' => 'Token inválido'], 401);
       }
   }
   ```

9. Registrar middleware en `bootstrap/app.php`:
   ```php
   ->withMiddleware(function (Middleware $middleware) {
       $middleware->alias([
           'auth.google' => \App\Http\Middleware\ValidateGoogleToken::class,
       ]);
   })
   ```

10. Crear request de validación:
    ```bash
    php artisan make:request CreateSessionRequest
    ```

11. Definir request:
    ```php
    public function rules(): array
    {
        return [
            'started_at' => 'required|date'
        ];
    }
    ```

12. Crear controlador:
    ```bash
    php artisan make:controller GameSessionController
    ```

13. Implementar método `store`:
    ```php
    public function store(CreateSessionRequest $request)
    {
        $user = $request->get('authenticated_user');

        $session = GameSession::create([
            'user_id' => $user->id,
            'started_at' => $request->started_at,
        ]);

        return response()->json([
            'success' => true,
            'data' => $session
        ], 201);
    }
    ```

14. Definir ruta:
    ```php
    Route::middleware('auth.google')->group(function () {
        Route::post('/sessions', [GameSessionController::class, 'store']);
    });
    ```

#### Frontend (2 horas)

**Tareas:**

1. Crear tipos TypeScript:
   ```typescript
   // src/types/api.ts (agregar)
   export interface GameSessionData {
     id: number;
     user_id: number;
     started_at: string;
     finished_at: string | null;
     final_score: number;
     max_level_reached: number;
     duration_seconds: number;
     created_at: string;
     updated_at: string;
   }
   ```

2. Crear servicio de sesiones:
   ```typescript
   // src/services/sessionApiService.ts
   import apiClient from './apiService';
   import type { ApiResponse, GameSessionData } from '../types/api';

   export const sessionApiService = {
     async createSession(startedAt: string): Promise<GameSessionData> {
       const response = await apiClient.post<ApiResponse<GameSessionData>>(
         '/sessions',
         { started_at: startedAt }
       );
       return response.data.data;
     }
   };
   ```

3. Modificar `GameScene.create()`:
   ```typescript
   // src/scenes/GameScene.ts
   import { sessionApiService } from '../services/sessionApiService';

   export class GameScene extends Phaser.Scene {
     private sessionId: number | null = null;

     async create(): Promise<void> {
       console.log('GameScene: Game started!');

       // Crear sesión en backend
       try {
         const session = await sessionApiService.createSession(
           new Date().toISOString()
         );
         this.sessionId = session.id;
         console.log('Sesión de juego creada:', session.id);
       } catch (error) {
         console.error('Error al crear sesión:', error);
         // Mostrar mensaje de error al usuario
         this.add.text(
           this.cameras.main.centerX,
           this.cameras.main.centerY,
           'Error al conectar con el servidor.\nNo se guardará el progreso.',
           {
             fontSize: '24px',
             color: '#ff0000',
             align: 'center'
           }
         ).setOrigin(0.5);
       }

       // ... resto del código existente
     }
   }
   ```

#### Testing Manual (30 minutos)

**Checklist de validación:**

- [ ] **Al iniciar el juego:**
  - [ ] Console muestra: "Sesión de juego creada: {id}"
  - [ ] Se crea registro en tabla `game_sessions`
  - [ ] `user_id` corresponde al usuario logueado
  - [ ] `started_at` tiene timestamp actual
  - [ ] `finished_at` es NULL
  - [ ] `final_score` es 0
  - [ ] `max_level_reached` es 1

- [ ] **Múltiples inicios de juego:**
  - [ ] Cada inicio crea nueva sesión
  - [ ] IDs son secuenciales
  - [ ] Todas las sesiones pertenecen al usuario correcto

- [ ] **Usuario no autenticado:**
  - [ ] Si no hay token → error 401
  - [ ] Frontend maneja el error apropiadamente

- [ ] **Verificar en base de datos:**
  - [ ] phpMyAdmin/Workbench → tabla `game_sessions`
  - [ ] Verificar relación con `users`

#### Testing Automático

```bash
php artisan make:test GameSessionTest
```

```php
// tests/Feature/GameSessionTest.php
class GameSessionTest extends TestCase
{
    use RefreshDatabase;

    /** @test */
    public function authenticated_user_can_create_game_session()
    {
        $user = User::factory()->create();

        $response = $this->actingAs($user)
            ->postJson('/api/sessions', [
                'started_at' => now()->toISOString()
            ]);

        $response->assertStatus(201)
            ->assertJsonStructure([
                'success',
                'data' => ['id', 'user_id', 'started_at']
            ]);

        $this->assertDatabaseHas('game_sessions', [
            'user_id' => $user->id,
        ]);
    }

    /** @test */
    public function unauthenticated_user_cannot_create_session()
    {
        $response = $this->postJson('/api/sessions', [
            'started_at' => now()->toISOString()
        ]);

        $response->assertStatus(401);
    }

    /** @test */
    public function session_belongs_to_correct_user()
    {
        $user1 = User::factory()->create();
        $user2 = User::factory()->create();

        $this->actingAs($user1)->postJson('/api/sessions', [
            'started_at' => now()->toISOString()
        ]);

        $this->assertDatabaseHas('game_sessions', [
            'user_id' => $user1->id
        ]);

        $this->assertDatabaseMissing('game_sessions', [
            'user_id' => $user2->id
        ]);
    }
}
```

**Ejecutar tests:**
```bash
php artisan test --filter GameSessionTest
```

#### ✋ CHECKPOINT 2

**NO AVANZAR AL INCREMENTO 3 SIN VALIDAR:**
- ✅ Todos los tests automáticos pasan
- ✅ Sesión se crea correctamente en BD
- ✅ Frontend recibe y almacena sessionId
- ✅ Console muestra sessionId claramente

---

### ✅ INCREMENTO 3: Registrar Disparos
**Duración estimada:** 7 horas
**Objetivo:** Cada disparo que impacta un card queda registrado en la base de datos

#### Backend (2-3 horas)

**Tareas:**

1. Crear migración:
   ```bash
   php artisan make:migration create_shots_table
   ```

2. Definir migración:
   ```php
   Schema::create('shots', function (Blueprint $table) {
       $table->id();
       $table->foreignId('game_session_id')->constrained()->onDelete('cascade');
       $table->timestamp('shot_at', 3); // Precisión de milisegundos
       $table->decimal('coordinate_x', 8, 2);
       $table->decimal('coordinate_y', 8, 2);
       $table->integer('factor_1');
       $table->integer('factor_2');
       $table->integer('correct_answer');
       $table->integer('card_value');
       $table->boolean('is_correct');
       $table->timestamps();

       $table->index('game_session_id');
       $table->index('is_correct');
       $table->index(['factor_1', 'factor_2']);
   });
   ```

3. Ejecutar migración:
   ```bash
   php artisan migrate
   ```

4. Crear modelo:
   ```bash
   php artisan make:model Shot
   ```

5. Definir modelo `Shot`:
   ```php
   class Shot extends Model
   {
       protected $fillable = [
           'game_session_id', 'shot_at',
           'coordinate_x', 'coordinate_y',
           'factor_1', 'factor_2',
           'correct_answer', 'card_value',
           'is_correct'
       ];

       protected $casts = [
           'shot_at' => 'datetime',
           'is_correct' => 'boolean',
           'coordinate_x' => 'float',
           'coordinate_y' => 'float',
       ];

       public function gameSession()
       {
           return $this->belongsTo(GameSession::class);
       }
   }
   ```

6. Crear request de validación:
   ```bash
   php artisan make:request RecordShotRequest
   ```

7. Definir request:
   ```php
   public function rules(): array
   {
       return [
           'shot_at' => 'required|date',
           'coordinate_x' => 'required|numeric|min:0|max:1200',
           'coordinate_y' => 'required|numeric|min:0|max:800',
           'factor_1' => 'required|integer|min:1|max:12',
           'factor_2' => 'required|integer|min:1|max:12',
           'correct_answer' => 'required|integer',
           'card_value' => 'required|integer',
           'is_correct' => 'required|boolean'
       ];
   }
   ```

8. Crear controlador:
   ```bash
   php artisan make:controller ShotController
   ```

9. Implementar método `store`:
   ```php
   public function store(RecordShotRequest $request, int $sessionId)
   {
       $user = $request->get('authenticated_user');

       // Buscar sesión
       $session = GameSession::find($sessionId);

       if (!$session) {
           return response()->json([
               'error' => 'Sesión no encontrada'
           ], 404);
       }

       // Verificar que la sesión pertenezca al usuario
       if ($session->user_id !== $user->id) {
           return response()->json([
               'error' => 'No autorizado'
           ], 403);
       }

       // Verificar que la sesión no esté finalizada
       if (!$session->isActive()) {
           return response()->json([
               'error' => 'La sesión ya finalizó'
           ], 400);
       }

       // Crear registro de disparo
       $shot = Shot::create([
           'game_session_id' => $sessionId,
           'shot_at' => $request->shot_at,
           'coordinate_x' => $request->coordinate_x,
           'coordinate_y' => $request->coordinate_y,
           'factor_1' => $request->factor_1,
           'factor_2' => $request->factor_2,
           'correct_answer' => $request->correct_answer,
           'card_value' => $request->card_value,
           'is_correct' => $request->is_correct,
       ]);

       return response()->json([
           'success' => true,
           'data' => $shot
       ], 201);
   }
   ```

10. Definir ruta:
    ```php
    Route::middleware('auth.google')->group(function () {
        Route::post('/sessions', [GameSessionController::class, 'store']);
        Route::post('/sessions/{id}/shots', [ShotController::class, 'store']);
    });
    ```

#### Frontend (3 horas)

**Tareas:**

1. Crear tipos TypeScript:
   ```typescript
   // src/types/api.ts (agregar)
   export interface ShotData {
     id: number;
     game_session_id: number;
     shot_at: string;
     coordinate_x: number;
     coordinate_y: number;
     factor_1: number;
     factor_2: number;
     correct_answer: number;
     card_value: number;
     is_correct: boolean;
     created_at: string;
     updated_at: string;
   }

   export interface RecordShotPayload {
     shot_at: string;
     coordinate_x: number;
     coordinate_y: number;
     factor_1: number;
     factor_2: number;
     correct_answer: number;
     card_value: number;
     is_correct: boolean;
   }
   ```

2. Crear servicio de disparos:
   ```typescript
   // src/services/shotApiService.ts
   import apiClient from './apiService';
   import type { ApiResponse, ShotData, RecordShotPayload } from '../types/api';

   export const shotApiService = {
     async recordShot(
       sessionId: number,
       shotData: RecordShotPayload
     ): Promise<ShotData> {
       const response = await apiClient.post<ApiResponse<ShotData>>(
         `/sessions/${sessionId}/shots`,
         shotData
       );
       return response.data.data;
     }
   };
   ```

3. Modificar `GameScene.onShoot()`:
   ```typescript
   // src/scenes/GameScene.ts
   import { shotApiService } from '../services/shotApiService';

   private async onShoot(pointer: Phaser.Input.Pointer): Promise<void> {
     // Reproducir sonido de disparo
     this.audioManager.play('shoot', { volume: 0.5 });

     // Crear marcador de disparo
     new ShotMarker(this, pointer.x, pointer.y);

     // Animación de feedback en la mira
     this.crosshair.pulse();

     // Verificar colisión con tarjetas
     const hitCard = this.cardSpawner.checkHit(pointer.x, pointer.y);

     if (hitCard) {
       const isCorrect = hitCard.isCorrect();

       // Actualizar puntuación y efectos visuales
       if (isCorrect) {
         this.scoreManager.addCorrectHit();
         hitCard.showHitCorrectEffect();
         this.questionDisplay.showCorrectFeedback();
       } else {
         this.scoreManager.addWrongHit();
         hitCard.showHitWrongEffect();
         this.questionDisplay.showWrongFeedback();
       }

       // Remover la tarjeta
       this.cardSpawner.removeCard(hitCard);

       // Registrar disparo en backend (solo si impactó un card)
       if (this.sessionId) {
         try {
           await shotApiService.recordShot(this.sessionId, {
             shot_at: new Date().toISOString(),
             coordinate_x: pointer.x,
             coordinate_y: pointer.y,
             factor_1: this.questionGenerator.getCurrentQuestion().factor1,
             factor_2: this.questionGenerator.getCurrentQuestion().factor2,
             correct_answer: this.questionGenerator.getCurrentQuestion().correctAnswer,
             card_value: hitCard.getValue(),
             is_correct: isCorrect
           });
           console.log('Disparo registrado en backend');
         } catch (error) {
           console.error('Error al registrar disparo:', error);
           // No interrumpir el juego si falla el registro
         }
       }
     }
   }
   ```

4. Actualizar `QuestionGenerator` para exponer pregunta actual:
   ```typescript
   // src/systems/QuestionGenerator.ts
   private currentQuestion: Question | null = null;

   public generateQuestion(): Question {
     // ... código existente
     this.currentQuestion = {
       factor1,
       factor2,
       correctAnswer
     };
     return this.currentQuestion;
   }

   public getCurrentQuestion(): Question {
     return this.currentQuestion!;
   }
   ```

#### Testing Manual (1 hora)

**Checklist de validación:**

- [ ] **Disparo correcto a card:**
  - [ ] Se crea registro en tabla `shots`
  - [ ] `is_correct` es `true`
  - [ ] `card_value` = `correct_answer`
  - [ ] Coordenadas X, Y correctas
  - [ ] `factor_1`, `factor_2`, `correct_answer` correctos
  - [ ] Console muestra: "Disparo registrado en backend"

- [ ] **Disparo incorrecto a card:**
  - [ ] Se crea registro en tabla `shots`
  - [ ] `is_correct` es `false`
  - [ ] `card_value` ≠ `correct_answer`
  - [ ] Resto de datos correctos

- [ ] **Disparo al aire (sin impactar card):**
  - [ ] NO se crea registro en tabla `shots`
  - [ ] Juego continúa normal

- [ ] **Múltiples disparos en una sesión:**
  - [ ] Todos tienen el mismo `game_session_id`
  - [ ] Timestamps son secuenciales
  - [ ] Contador de registros aumenta correctamente

- [ ] **Sesión finalizada:**
  - [ ] Si intentamos registrar disparo → error 400
  - [ ] Frontend maneja el error sin romper el juego

- [ ] **Sesión de otro usuario:**
  - [ ] No se puede registrar disparo → error 403

- [ ] **Verificar en base de datos:**
  - [ ] Ver tabla `shots`
  - [ ] Verificar relación con `game_sessions`
  - [ ] Timestamp con precisión de milisegundos

#### Testing Automático

```bash
php artisan make:test ShotTest
```

```php
// tests/Feature/ShotTest.php
class ShotTest extends TestCase
{
    use RefreshDatabase;

    /** @test */
    public function can_record_correct_shot()
    {
        $user = User::factory()->create();
        $session = GameSession::factory()->create(['user_id' => $user->id]);

        $response = $this->actingAs($user)
            ->postJson("/api/sessions/{$session->id}/shots", [
                'shot_at' => now()->toISOString(),
                'coordinate_x' => 500,
                'coordinate_y' => 300,
                'factor_1' => 7,
                'factor_2' => 8,
                'correct_answer' => 56,
                'card_value' => 56,
                'is_correct' => true
            ]);

        $response->assertStatus(201);

        $this->assertDatabaseHas('shots', [
            'game_session_id' => $session->id,
            'is_correct' => true,
            'card_value' => 56
        ]);
    }

    /** @test */
    public function can_record_wrong_shot()
    {
        $user = User::factory()->create();
        $session = GameSession::factory()->create(['user_id' => $user->id]);

        $response = $this->actingAs($user)
            ->postJson("/api/sessions/{$session->id}/shots", [
                'shot_at' => now()->toISOString(),
                'coordinate_x' => 500,
                'coordinate_y' => 300,
                'factor_1' => 7,
                'factor_2' => 8,
                'correct_answer' => 56,
                'card_value' => 48,
                'is_correct' => false
            ]);

        $response->assertStatus(201);

        $this->assertDatabaseHas('shots', [
            'is_correct' => false,
            'card_value' => 48,
            'correct_answer' => 56
        ]);
    }

    /** @test */
    public function cannot_record_shot_in_finished_session()
    {
        $user = User::factory()->create();
        $session = GameSession::factory()->create([
            'user_id' => $user->id,
            'finished_at' => now()
        ]);

        $response = $this->actingAs($user)
            ->postJson("/api/sessions/{$session->id}/shots", [
                'shot_at' => now()->toISOString(),
                'coordinate_x' => 500,
                'coordinate_y' => 300,
                'factor_1' => 7,
                'factor_2' => 8,
                'correct_answer' => 56,
                'card_value' => 56,
                'is_correct' => true
            ]);

        $response->assertStatus(400);
    }

    /** @test */
    public function cannot_record_shot_in_other_user_session()
    {
        $user1 = User::factory()->create();
        $user2 = User::factory()->create();
        $session = GameSession::factory()->create(['user_id' => $user1->id]);

        $response = $this->actingAs($user2)
            ->postJson("/api/sessions/{$session->id}/shots", [
                'shot_at' => now()->toISOString(),
                'coordinate_x' => 500,
                'coordinate_y' => 300,
                'factor_1' => 7,
                'factor_2' => 8,
                'correct_answer' => 56,
                'card_value' => 56,
                'is_correct' => true
            ]);

        $response->assertStatus(403);
    }
}
```

**Ejecutar tests:**
```bash
php artisan test --filter ShotTest
```

#### ✋ CHECKPOINT 3

**NO AVANZAR AL INCREMENTO 4 SIN VALIDAR:**
- ✅ Todos los tests automáticos pasan
- ✅ Disparos correctos e incorrectos se registran
- ✅ Disparos al aire NO se registran
- ✅ Validaciones de seguridad funcionan (sesión finalizada, otro usuario)
- ✅ Console muestra confirmación de registro

---

### ✅ INCREMENTO 4: Finalizar Sesión
**Duración estimada:** 4.5 horas
**Objetivo:** Al terminar la sesión de 5 minutos, guardar el puntaje final y estadísticas

#### Backend (2 horas)

**Tareas:**

1. Crear request de validación:
   ```bash
   php artisan make:request FinishSessionRequest
   ```

2. Definir request:
   ```php
   public function rules(): array
   {
       return [
           'finished_at' => 'required|date',
           'final_score' => 'required|integer|min:0',
           'max_level_reached' => 'required|integer|min:1',
           'duration_seconds' => 'required|integer|min:0|max:600'
       ];
   }
   ```

3. Implementar método `finish` en `GameSessionController`:
   ```php
   public function finish(FinishSessionRequest $request, int $id)
   {
       $user = $request->get('authenticated_user');

       $session = GameSession::find($id);

       if (!$session) {
           return response()->json(['error' => 'Sesión no encontrada'], 404);
       }

       if ($session->user_id !== $user->id) {
           return response()->json(['error' => 'No autorizado'], 403);
       }

       if (!$session->isActive()) {
           return response()->json([
               'error' => 'La sesión ya fue finalizada'
           ], 400);
       }

       // Actualizar datos de la sesión
       $session->update([
           'finished_at' => $request->finished_at,
           'final_score' => $request->final_score,
           'max_level_reached' => $request->max_level_reached,
           'duration_seconds' => $request->duration_seconds,
       ]);

       // Calcular estadísticas automáticas
       $totalShots = $session->shots()->count();
       $correctShots = $session->shots()->where('is_correct', true)->count();
       $wrongShots = $session->shots()->where('is_correct', false)->count();
       $accuracy = $totalShots > 0 ? round(($correctShots / $totalShots) * 100, 2) : 0;

       return response()->json([
           'success' => true,
           'data' => [
               'id' => $session->id,
               'user_id' => $session->user_id,
               'started_at' => $session->started_at,
               'finished_at' => $session->finished_at,
               'final_score' => $session->final_score,
               'max_level_reached' => $session->max_level_reached,
               'duration_seconds' => $session->duration_seconds,
               'total_shots' => $totalShots,
               'correct_shots' => $correctShots,
               'wrong_shots' => $wrongShots,
               'accuracy' => $accuracy,
               'created_at' => $session->created_at,
           ]
       ]);
   }
   ```

4. Definir ruta:
   ```php
   Route::middleware('auth.google')->group(function () {
       Route::post('/sessions', [GameSessionController::class, 'store']);
       Route::post('/sessions/{id}/shots', [ShotController::class, 'store']);
       Route::put('/sessions/{id}/finish', [GameSessionController::class, 'finish']);
   });
   ```

#### Frontend (2 horas)

**Tareas:**

1. Actualizar tipos TypeScript:
   ```typescript
   // src/types/api.ts (agregar)
   export interface FinishSessionPayload {
     finished_at: string;
     final_score: number;
     max_level_reached: number;
     duration_seconds: number;
   }

   export interface FinishedSessionData extends GameSessionData {
     total_shots: number;
     correct_shots: number;
     wrong_shots: number;
     accuracy: number;
   }
   ```

2. Actualizar servicio de sesiones:
   ```typescript
   // src/services/sessionApiService.ts (agregar método)
   async finishSession(
     sessionId: number,
     finishData: FinishSessionPayload
   ): Promise<FinishedSessionData> {
     const response = await apiClient.put<ApiResponse<FinishedSessionData>>(
       `/sessions/${sessionId}/finish`,
       finishData
     );
     return response.data.data;
   }
   ```

3. Modificar `GameScene.endSession()`:
   ```typescript
   // src/scenes/GameScene.ts
   private async endSession(): Promise<void> {
     // Detener spawn de tarjetas
     this.cardSpawner.stopSpawning();

     // Cancelar timer de sesión
     if (this.sessionTimer) {
       this.sessionTimer.remove();
     }

     console.log('¡SESIÓN COMPLETADA!');

     // Finalizar sesión en backend
     if (this.sessionId) {
       try {
         const elapsedTime = this.progressionManager.getElapsedTime();
         const finishedSession = await sessionApiService.finishSession(
           this.sessionId,
           {
             finished_at: new Date().toISOString(),
             final_score: this.scoreManager.getScore(),
             max_level_reached: this.progressionManager.getCurrentLevel(),
             duration_seconds: Math.floor(elapsedTime / 1000)
           }
         );

         console.log('Sesión finalizada en backend:', finishedSession);

         // Mostrar resumen con datos del backend
         this.showSessionSummary(finishedSession);

       } catch (error) {
         console.error('Error al finalizar sesión en backend:', error);
         // Mostrar resumen con datos locales si falla el backend
         this.showSessionSummaryLocal();
       }
     } else {
       // Si no hay sessionId, mostrar resumen local
       this.showSessionSummaryLocal();
     }
   }

   private showSessionSummary(sessionData: FinishedSessionData): void {
     const info = this.progressionManager.getProgressInfo();

     // Crear overlay oscuro
     const overlay = this.add.rectangle(
       this.cameras.main.centerX,
       this.cameras.main.centerY,
       this.cameras.main.width,
       this.cameras.main.height,
       0x000000,
       0.8
     );
     overlay.setDepth(3000);

     // Título
     const summaryText = this.add.text(
       this.cameras.main.centerX,
       this.cameras.main.centerY - 200,
       '¡SESIÓN COMPLETADA!',
       {
         fontSize: '64px',
         color: '#ffff00',
         fontStyle: 'bold',
         stroke: '#000000',
         strokeThickness: 8
       }
     );
     summaryText.setOrigin(0.5);
     summaryText.setDepth(3001);

     // Estadísticas (usando datos del backend)
     const statsText = this.add.text(
       this.cameras.main.centerX,
       this.cameras.main.centerY - 50,
       `Puntuación Final: ${sessionData.final_score}\n` +
       `Nivel Alcanzado: ${sessionData.max_level_reached}\n` +
       `Última Tabla: Tabla del ${info.table}\n` +
       `Disparos Totales: ${sessionData.total_shots}\n` +
       `Aciertos: ${sessionData.correct_shots} | Errores: ${sessionData.wrong_shots}\n` +
       `Precisión: ${sessionData.accuracy}%\n` +
       `Tiempo Jugado: ${Math.floor(sessionData.duration_seconds / 60)}:${(sessionData.duration_seconds % 60).toString().padStart(2, '0')}`,
       {
         fontSize: '28px',
         color: '#ffffff',
         fontStyle: 'bold',
         align: 'center',
         lineSpacing: 10
       }
     );
     statsText.setOrigin(0.5);
     statsText.setDepth(3001);

     // Botón de reinicio
     const restartText = this.add.text(
       this.cameras.main.centerX,
       this.cameras.main.centerY + 180,
       'Haz clic para nueva sesión',
       {
         fontSize: '28px',
         color: '#00ff00',
         fontStyle: 'italic'
       }
     );
     restartText.setOrigin(0.5);
     restartText.setDepth(3001);

     // Animación de parpadeo
     this.tweens.add({
       targets: restartText,
       alpha: 0.3,
       duration: 800,
       ease: 'Sine.easeInOut',
       yoyo: true,
       repeat: -1
     });

     // Reiniciar al hacer clic
     this.input.once('pointerdown', () => {
       this.showRestartConfirmation(overlay, summaryText, statsText, restartText);
     });
   }

   private showSessionSummaryLocal(): void {
     // Versión de respaldo usando solo datos locales
     const info = this.progressionManager.getProgressInfo();
     const finalScore = this.scoreManager.getScore();

     // ... código similar pero con datos locales
   }
   ```

#### Testing Manual (30 minutos)

**Checklist de validación:**

- [ ] **Al finalizar sesión (5 minutos):**
  - [ ] `finished_at` actualizado en tabla `game_sessions`
  - [ ] `final_score` correcto
  - [ ] `max_level_reached` correcto
  - [ ] `duration_seconds` ≈ 300 segundos
  - [ ] Console muestra: "Sesión finalizada en backend: {datos}"

- [ ] **Pantalla de resumen:**
  - [ ] Muestra datos del backend (no locales)
  - [ ] Total de disparos correcto
  - [ ] Aciertos y errores correctos
  - [ ] Precisión calculada correctamente
  - [ ] Tiempo mostrado en formato MM:SS

- [ ] **Intentar finalizar sesión ya finalizada:**
  - [ ] Backend retorna error 400
  - [ ] Frontend maneja el error

- [ ] **Intentar registrar disparo después de finalizar:**
  - [ ] Backend retorna error 400
  - [ ] No se crea registro en tabla `shots`

- [ ] **Verificar en base de datos:**
  - [ ] `finished_at` NO es NULL
  - [ ] Todos los campos actualizados
  - [ ] Sesión marcada como inactiva

#### Testing Automático

```bash
php artisan make:test FinishSessionTest
```

```php
// tests/Feature/FinishSessionTest.php
class FinishSessionTest extends TestCase
{
    use RefreshDatabase;

    /** @test */
    public function can_finish_session_with_correct_data()
    {
        $user = User::factory()->create();
        $session = GameSession::factory()->create([
            'user_id' => $user->id,
            'finished_at' => null
        ]);

        $response = $this->actingAs($user)
            ->putJson("/api/sessions/{$session->id}/finish", [
                'finished_at' => now()->toISOString(),
                'final_score' => 120,
                'max_level_reached' => 4,
                'duration_seconds' => 300
            ]);

        $response->assertStatus(200)
            ->assertJsonStructure([
                'success',
                'data' => [
                    'final_score', 'max_level_reached',
                    'total_shots', 'accuracy'
                ]
            ]);

        $this->assertDatabaseHas('game_sessions', [
            'id' => $session->id,
            'final_score' => 120,
            'max_level_reached' => 4
        ]);

        $session->refresh();
        $this->assertNotNull($session->finished_at);
    }

    /** @test */
    public function cannot_finish_already_finished_session()
    {
        $user = User::factory()->create();
        $session = GameSession::factory()->create([
            'user_id' => $user->id,
            'finished_at' => now()
        ]);

        $response = $this->actingAs($user)
            ->putJson("/api/sessions/{$session->id}/finish", [
                'finished_at' => now()->toISOString(),
                'final_score' => 120,
                'max_level_reached' => 4,
                'duration_seconds' => 300
            ]);

        $response->assertStatus(400);
    }

    /** @test */
    public function cannot_finish_other_user_session()
    {
        $user1 = User::factory()->create();
        $user2 = User::factory()->create();
        $session = GameSession::factory()->create(['user_id' => $user1->id]);

        $response = $this->actingAs($user2)
            ->putJson("/api/sessions/{$session->id}/finish", [
                'finished_at' => now()->toISOString(),
                'final_score' => 120,
                'max_level_reached' => 4,
                'duration_seconds' => 300
            ]);

        $response->assertStatus(403);
    }

    /** @test */
    public function calculates_accuracy_correctly()
    {
        $user = User::factory()->create();
        $session = GameSession::factory()->create(['user_id' => $user->id]);

        // Crear 10 disparos: 7 correctos, 3 incorrectos
        Shot::factory()->count(7)->create([
            'game_session_id' => $session->id,
            'is_correct' => true
        ]);
        Shot::factory()->count(3)->create([
            'game_session_id' => $session->id,
            'is_correct' => false
        ]);

        $response = $this->actingAs($user)
            ->putJson("/api/sessions/{$session->id}/finish", [
                'finished_at' => now()->toISOString(),
                'final_score' => 55,
                'max_level_reached' => 2,
                'duration_seconds' => 300
            ]);

        $response->assertStatus(200)
            ->assertJson([
                'data' => [
                    'total_shots' => 10,
                    'correct_shots' => 7,
                    'wrong_shots' => 3,
                    'accuracy' => 70.0
                ]
            ]);
    }
}
```

**Ejecutar tests:**
```bash
php artisan test --filter FinishSessionTest
```

#### ✋ CHECKPOINT 4

**NO AVANZAR AL INCREMENTO 5 SIN VALIDAR:**
- ✅ Todos los tests automáticos pasan
- ✅ Sesión se finaliza correctamente
- ✅ Estadísticas calculadas automáticamente
- ✅ Pantalla de resumen muestra datos del backend
- ✅ No se pueden registrar disparos después de finalizar

---

### ✅ INCREMENTO 5: Estadísticas Básicas
**Duración estimada:** 7 horas
**Objetivo:** Ver historial de sesiones del usuario autenticado

#### Backend (3 horas)

**Tareas:**

1. Crear API Resource:
   ```bash
   php artisan make:resource GameSessionResource
   php artisan make:resource ShotResource
   ```

2. Definir `GameSessionResource`:
   ```php
   public function toArray($request): array
   {
       return [
           'id' => $this->id,
           'user_id' => $this->user_id,
           'started_at' => $this->started_at,
           'finished_at' => $this->finished_at,
           'final_score' => $this->final_score,
           'max_level_reached' => $this->max_level_reached,
           'duration_seconds' => $this->duration_seconds,
           'total_shots' => $this->shots()->count(),
           'correct_shots' => $this->shots()->where('is_correct', true)->count(),
           'accuracy' => $this->calculateAccuracy(),
           'created_at' => $this->created_at,
       ];
   }

   private function calculateAccuracy(): float
   {
       $total = $this->shots()->count();
       if ($total === 0) return 0;

       $correct = $this->shots()->where('is_correct', true)->count();
       return round(($correct / $total) * 100, 2);
   }
   ```

3. Definir `ShotResource`:
   ```php
   public function toArray($request): array
   {
       return [
           'id' => $this->id,
           'shot_at' => $this->shot_at,
           'coordinate_x' => $this->coordinate_x,
           'coordinate_y' => $this->coordinate_y,
           'factor_1' => $this->factor_1,
           'factor_2' => $this->factor_2,
           'correct_answer' => $this->correct_answer,
           'card_value' => $this->card_value,
           'is_correct' => $this->is_correct,
       ];
   }
   ```

4. Implementar métodos `index` y `show` en `GameSessionController`:
   ```php
   public function index(Request $request)
   {
       $user = $request->get('authenticated_user');

       $sessions = GameSession::where('user_id', $user->id)
           ->orderBy('started_at', 'desc')
           ->paginate(10);

       return GameSessionResource::collection($sessions);
   }

   public function show(Request $request, int $id)
   {
       $user = $request->get('authenticated_user');

       $session = GameSession::with('shots')
           ->where('id', $id)
           ->where('user_id', $user->id)
           ->first();

       if (!$session) {
           return response()->json(['error' => 'Sesión no encontrada'], 404);
       }

       return response()->json([
           'success' => true,
           'data' => [
               'session' => new GameSessionResource($session),
               'shots' => ShotResource::collection($session->shots)
           ]
       ]);
   }
   ```

5. Definir rutas:
   ```php
   Route::middleware('auth.google')->group(function () {
       Route::post('/sessions', [GameSessionController::class, 'store']);
       Route::put('/sessions/{id}/finish', [GameSessionController::class, 'finish']);
       Route::get('/sessions', [GameSessionController::class, 'index']);
       Route::get('/sessions/{id}', [GameSessionController::class, 'show']);
       Route::post('/sessions/{id}/shots', [ShotController::class, 'store']);
   });
   ```

#### Frontend (3 horas)

**Tareas:**

1. Actualizar tipos TypeScript:
   ```typescript
   // src/types/api.ts
   export interface SessionListItem {
     id: number;
     started_at: string;
     finished_at: string;
     final_score: number;
     max_level_reached: number;
     duration_seconds: number;
     total_shots: number;
     correct_shots: number;
     accuracy: number;
   }

   export interface SessionDetail {
     session: SessionListItem;
     shots: ShotData[];
   }
   ```

2. Actualizar servicio de sesiones:
   ```typescript
   // src/services/sessionApiService.ts
   async getSessions(page: number = 1): Promise<{
     data: SessionListItem[];
     meta: any;
   }> {
     const response = await apiClient.get(`/sessions?page=${page}`);
     return response.data;
   }

   async getSessionDetail(sessionId: number): Promise<SessionDetail> {
     const response = await apiClient.get<ApiResponse<SessionDetail>>(
       `/sessions/${sessionId}`
     );
     return response.data.data;
   }
   ```

3. Crear nueva escena de estadísticas:
   ```bash
   # Archivo: src/scenes/StatsScene.ts
   ```

4. Implementar `StatsScene`:
   ```typescript
   import Phaser from 'phaser';
   import { sessionApiService } from '../services/sessionApiService';
   import type { SessionListItem } from '../types/api';

   export class StatsScene extends Phaser.Scene {
     private sessions: SessionListItem[] = [];
     private currentPage: number = 1;

     constructor() {
       super({ key: 'StatsScene' });
     }

     async create(): Promise<void> {
       // Fondo
       this.cameras.main.setBackgroundColor('#1a1a2e');

       // Título
       this.add.text(
         this.cameras.main.centerX,
         50,
         'HISTORIAL DE SESIONES',
         {
           fontSize: '48px',
           color: '#ffff00',
           fontStyle: 'bold'
         }
       ).setOrigin(0.5);

       // Botón volver
       const backBtn = this.add.text(50, 50, '← Volver al Juego', {
         fontSize: '24px',
         color: '#ffffff',
         backgroundColor: '#444444',
         padding: { x: 15, y: 10 }
       });
       backBtn.setInteractive({ useHandCursor: true });
       backBtn.on('pointerdown', () => {
         this.scene.start('GameScene');
       });

       // Cargar sesiones
       await this.loadSessions();
     }

     private async loadSessions(): Promise<void> {
       try {
         const response = await sessionApiService.getSessions(this.currentPage);
         this.sessions = response.data;

         this.displaySessions();

       } catch (error) {
         console.error('Error al cargar sesiones:', error);

         this.add.text(
           this.cameras.main.centerX,
           this.cameras.main.centerY,
           'Error al cargar sesiones',
           {
             fontSize: '32px',
             color: '#ff0000'
           }
         ).setOrigin(0.5);
       }
     }

     private displaySessions(): void {
       const startY = 150;
       const lineHeight = 80;

       if (this.sessions.length === 0) {
         this.add.text(
           this.cameras.main.centerX,
           this.cameras.main.centerY,
           'No hay sesiones registradas',
           {
             fontSize: '32px',
             color: '#888888'
           }
         ).setOrigin(0.5);
         return;
       }

       this.sessions.forEach((session, index) => {
         const y = startY + (index * lineHeight);

         const date = new Date(session.started_at);
         const dateStr = date.toLocaleDateString('es-ES');
         const timeStr = date.toLocaleTimeString('es-ES', {
           hour: '2-digit',
           minute: '2-digit'
         });

         const container = this.add.container(100, y);

         // Fondo
         const bg = this.add.rectangle(
           500, 0,
           1000, 70,
           0x2c3e50, 0.8
         );
         bg.setStrokeStyle(2, 0x3498db);

         // Datos de la sesión
         const text = this.add.text(20, 0,
           `${dateStr} ${timeStr} | ` +
           `Puntaje: ${session.final_score} | ` +
           `Nivel: ${session.max_level_reached} | ` +
           `Precisión: ${session.accuracy}% | ` +
           `Disparos: ${session.total_shots}`,
           {
             fontSize: '22px',
             color: '#ffffff'
           }
         );
         text.setOrigin(0, 0.5);

         container.add([bg, text]);

         // Hacer clickeable
         bg.setInteractive({ useHandCursor: true });
         bg.on('pointerover', () => bg.setFillStyle(0x34495e));
         bg.on('pointerout', () => bg.setFillStyle(0x2c3e50));
         bg.on('pointerdown', () => {
           this.showSessionDetail(session.id);
         });
       });
     }

     private async showSessionDetail(sessionId: number): Promise<void> {
       try {
         const detail = await sessionApiService.getSessionDetail(sessionId);

         console.log('Detalle de sesión:', detail);

         // Mostrar modal con disparos
         this.showDetailModal(detail);

       } catch (error) {
         console.error('Error al cargar detalle:', error);
       }
     }

     private showDetailModal(detail: SessionDetail): void {
       // Overlay oscuro
       const overlay = this.add.rectangle(
         this.cameras.main.centerX,
         this.cameras.main.centerY,
         this.cameras.main.width,
         this.cameras.main.height,
         0x000000,
         0.9
       );
       overlay.setDepth(5000);
       overlay.setInteractive();

       // Contenido
       const content = this.add.text(
         this.cameras.main.centerX,
         this.cameras.main.centerY - 150,
         `DETALLE DE SESIÓN #${detail.session.id}\n\n` +
         `Puntaje: ${detail.session.final_score}\n` +
         `Nivel máximo: ${detail.session.max_level_reached}\n` +
         `Total de disparos: ${detail.session.total_shots}\n` +
         `Aciertos: ${detail.session.correct_shots}\n` +
         `Precisión: ${detail.session.accuracy}%\n\n` +
         `Disparos registrados: ${detail.shots.length}`,
         {
           fontSize: '28px',
           color: '#ffffff',
           align: 'center',
           lineSpacing: 10
         }
       );
       content.setOrigin(0.5);
       content.setDepth(5001);

       // Botón cerrar
       const closeBtn = this.add.text(
         this.cameras.main.centerX,
         this.cameras.main.centerY + 200,
         'Cerrar',
         {
           fontSize: '32px',
           color: '#00ff00',
           backgroundColor: '#004400',
           padding: { x: 30, y: 15 }
         }
       );
       closeBtn.setOrigin(0.5);
       closeBtn.setDepth(5001);
       closeBtn.setInteractive({ useHandCursor: true });

       closeBtn.on('pointerdown', () => {
         overlay.destroy();
         content.destroy();
         closeBtn.destroy();
       });
     }
   }
   ```

5. Registrar escena en `gameConfig.ts`:
   ```typescript
   import { StatsScene } from '../scenes/StatsScene';

   scene: [PreloadScene, LoginScene, GameScene, StatsScene]
   ```

6. Agregar botón en `GameScene` para ir a estadísticas:
   ```typescript
   // En GameScene.create() después de crear userMenu
   const statsBtn = this.add.text(
     this.cameras.main.width - 50,
     50,
     'Ver Estadísticas',
     {
       fontSize: '20px',
       color: '#ffffff',
       backgroundColor: '#4444ff',
       padding: { x: 15, y: 10 }
     }
   );
   statsBtn.setOrigin(1, 0);
   statsBtn.setDepth(2000);
   statsBtn.setInteractive({ useHandCursor: true });

   statsBtn.on('pointerdown', () => {
     this.scene.start('StatsScene');
   });
   ```

#### Testing Manual (1 hora)

**Checklist de validación:**

- [ ] **Listado de sesiones:**
  - [ ] Se muestran todas las sesiones del usuario
  - [ ] Orden descendente (más reciente primero)
  - [ ] Datos mostrados correctamente
  - [ ] Paginación funciona (si hay más de 10)

- [ ] **Detalle de sesión:**
  - [ ] Click en sesión abre modal
  - [ ] Muestra todos los datos
  - [ ] Cantidad de disparos correcta
  - [ ] Botón cerrar funciona

- [ ] **Performance:**
  - [ ] Lista carga en < 1 segundo
  - [ ] Detalle carga en < 500ms

- [ ] **Seguridad:**
  - [ ] Solo se muestran sesiones del usuario autenticado
  - [ ] No se pueden ver sesiones de otros usuarios

#### Testing Automático

```php
/** @test */
public function user_can_see_own_sessions()
{
    $user = User::factory()->create();
    GameSession::factory()->count(5)->create(['user_id' => $user->id]);

    $response = $this->actingAs($user)->getJson('/api/sessions');

    $response->assertStatus(200)
        ->assertJsonCount(5, 'data');
}

/** @test */
public function user_cannot_see_other_user_sessions()
{
    $user1 = User::factory()->create();
    $user2 = User::factory()->create();

    GameSession::factory()->count(3)->create(['user_id' => $user2->id]);

    $response = $this->actingAs($user1)->getJson('/api/sessions');

    $response->assertStatus(200)
        ->assertJsonCount(0, 'data');
}
```

#### ✋ CHECKPOINT 5

**NO AVANZAR AL INCREMENTO 6 SIN VALIDAR:**
- ✅ Listado de sesiones funciona
- ✅ Detalle de sesión muestra disparos
- ✅ Solo se muestran datos del usuario autenticado
- ✅ Performance aceptable

---

### ✅ INCREMENTO 6: Estadísticas Avanzadas
**Duración estimada:** 8 horas
**Objetivo:** Análisis de desempeño por tabla de multiplicar

#### Backend (4 horas)

**Tareas:**

1. Crear servicio de estadísticas:
   ```bash
   php artisan make:service StatsService
   ```

2. Implementar `StatsService`:
   ```php
   namespace App\Services;

   use App\Models\User;
   use App\Models\GameSession;
   use App\Models\Shot;
   use Illuminate\Support\Facades\DB;

   class StatsService
   {
       public function getUserStats(User $user): array
       {
           $sessions = GameSession::where('user_id', $user->id)->get();

           $totalSessions = $sessions->count();
           $totalShots = Shot::whereIn(
               'game_session_id',
               $sessions->pluck('id')
           )->count();

           $correctShots = Shot::whereIn(
               'game_session_id',
               $sessions->pluck('id')
           )->where('is_correct', true)->count();

           $wrongShots = $totalShots - $correctShots;

           $overallAccuracy = $totalShots > 0
               ? round(($correctShots / $totalShots) * 100, 2)
               : 0;

           $averageScore = $sessions->avg('final_score') ?? 0;
           $bestScore = $sessions->max('final_score') ?? 0;
           $totalPlaytime = $sessions->sum('duration_seconds') ?? 0;

           return [
               'total_sessions' => $totalSessions,
               'total_shots' => $totalShots,
               'total_correct' => $correctShots,
               'total_wrong' => $wrongShots,
               'overall_accuracy' => $overallAccuracy,
               'average_score' => round($averageScore, 2),
               'best_score' => $bestScore,
               'total_playtime_minutes' => round($totalPlaytime / 60, 2),
           ];
       }

       public function getTableStats(User $user): array
       {
           $sessionIds = GameSession::where('user_id', $user->id)
               ->pluck('id');

           $tableStats = [];

           for ($table = 1; $table <= 10; $table++) {
               $shots = Shot::whereIn('game_session_id', $sessionIds)
                   ->where(function ($query) use ($table) {
                       $query->where('factor_1', $table)
                           ->orWhere('factor_2', $table);
                   })
                   ->get();

               $total = $shots->count();
               $correct = $shots->where('is_correct', true)->count();
               $accuracy = $total > 0
                   ? round(($correct / $total) * 100, 2)
                   : 0;

               $tableStats[] = [
                   'table' => $table,
                   'total_attempts' => $total,
                   'correct_attempts' => $correct,
                   'wrong_attempts' => $total - $correct,
                   'accuracy' => $accuracy,
               ];
           }

           // Ordenar por precisión (ascendente) para identificar tablas difíciles
           usort($tableStats, fn($a, $b) => $a['accuracy'] <=> $b['accuracy']);

           return $tableStats;
       }

       public function getProgressHistory(User $user, int $limit = 10): array
       {
           $sessions = GameSession::where('user_id', $user->id)
               ->whereNotNull('finished_at')
               ->orderBy('started_at', 'desc')
               ->limit($limit)
               ->get();

           return $sessions->map(function ($session) {
               $totalShots = $session->shots()->count();
               $correctShots = $session->shots()->where('is_correct', true)->count();
               $accuracy = $totalShots > 0
                   ? round(($correctShots / $totalShots) * 100, 2)
                   : 0;

               return [
                   'id' => $session->id,
                   'started_at' => $session->started_at,
                   'final_score' => $session->final_score,
                   'max_level_reached' => $session->max_level_reached,
                   'accuracy' => $accuracy,
               ];
           })->reverse()->values()->all();
       }
   }
   ```

3. Crear controlador:
   ```bash
   php artisan make:controller StatsController
   ```

4. Implementar `StatsController`:
   ```php
   use App\Services\StatsService;

   class StatsController extends Controller
   {
       private StatsService $statsService;

       public function __construct(StatsService $statsService)
       {
           $this->statsService = $statsService;
       }

       public function userStats(Request $request)
       {
           $user = $request->get('authenticated_user');

           $stats = $this->statsService->getUserStats($user);

           return response()->json([
               'success' => true,
               'data' => $stats
           ]);
       }

       public function tableStats(Request $request)
       {
           $user = $request->get('authenticated_user');

           $stats = $this->statsService->getTableStats($user);

           return response()->json([
               'success' => true,
               'data' => $stats
           ]);
       }

       public function progress(Request $request)
       {
           $user = $request->get('authenticated_user');
           $limit = $request->get('limit', 10);

           $progress = $this->statsService->getProgressHistory($user, $limit);

           return response()->json([
               'success' => true,
               'data' => $progress
           ]);
       }
   }
   ```

5. Definir rutas:
   ```php
   Route::middleware('auth.google')->group(function () {
       // ... rutas existentes

       Route::get('/stats/user', [StatsController::class, 'userStats']);
       Route::get('/stats/tables', [StatsController::class, 'tableStats']);
       Route::get('/stats/progress', [StatsController::class, 'progress']);
   });
   ```

#### Frontend (3 horas)

**Tareas:**

1. Crear tipos TypeScript:
   ```typescript
   // src/types/api.ts
   export interface UserStats {
     total_sessions: number;
     total_shots: number;
     total_correct: number;
     total_wrong: number;
     overall_accuracy: number;
     average_score: number;
     best_score: number;
     total_playtime_minutes: number;
   }

   export interface TableStat {
     table: number;
     total_attempts: number;
     correct_attempts: number;
     wrong_attempts: number;
     accuracy: number;
   }
   ```

2. Crear servicio de estadísticas:
   ```typescript
   // src/services/statsApiService.ts
   import apiClient from './apiService';
   import type { ApiResponse, UserStats, TableStat } from '../types/api';

   export const statsApiService = {
     async getUserStats(): Promise<UserStats> {
       const response = await apiClient.get<ApiResponse<UserStats>>(
         '/stats/user'
       );
       return response.data.data;
     },

     async getTableStats(): Promise<TableStat[]> {
       const response = await apiClient.get<ApiResponse<TableStat[]>>(
         '/stats/tables'
       );
       return response.data.data;
     }
   };
   ```

3. Actualizar `StatsScene` para mostrar estadísticas avanzadas:
   ```typescript
   // Agregar al create()
   private async loadAdvancedStats(): Promise<void> {
     try {
       const userStats = await statsApiService.getUserStats();
       const tableStats = await statsApiService.getTableStats();

       this.displayUserStats(userStats);
       this.displayTableStats(tableStats);

     } catch (error) {
       console.error('Error al cargar estadísticas:', error);
     }
   }

   private displayUserStats(stats: UserStats): void {
     const text = this.add.text(100, 150,
       `ESTADÍSTICAS GENERALES\n\n` +
       `Total de sesiones: ${stats.total_sessions}\n` +
       `Disparos totales: ${stats.total_shots}\n` +
       `Aciertos: ${stats.total_correct} | Errores: ${stats.total_wrong}\n` +
       `Precisión global: ${stats.overall_accuracy}%\n` +
       `Puntaje promedio: ${stats.average_score}\n` +
       `Mejor puntaje: ${stats.best_score}\n` +
       `Tiempo total jugado: ${stats.total_playtime_minutes} min`,
       {
         fontSize: '24px',
         color: '#ffffff',
         lineSpacing: 8
       }
     );
   }

   private displayTableStats(stats: TableStat[]): void {
     const startY = 450;

     this.add.text(100, 420, 'DESEMPEÑO POR TABLA:', {
       fontSize: '28px',
       color: '#ffff00',
       fontStyle: 'bold'
     });

     stats.slice(0, 5).forEach((tableStat, index) => {
       const y = startY + (index * 40);

       const color = tableStat.accuracy >= 70 ? '#00ff00' : '#ff0000';

       this.add.text(100, y,
         `Tabla del ${tableStat.table}: ${tableStat.total_attempts} intentos | ` +
         `Precisión: ${tableStat.accuracy}%`,
         {
           fontSize: '22px',
           color: color
         }
       );
     });

     // Identificar tabla más difícil
     const mostDifficult = stats[0];
     this.add.text(100, startY + 220,
       `⚠️ Tabla más difícil: Tabla del ${mostDifficult.table} (${mostDifficult.accuracy}%)`,
       {
         fontSize: '24px',
         color: '#ff6600',
         fontStyle: 'bold'
       }
     );
   }
   ```

#### Testing Manual (1 hora)

**Checklist:**
- [ ] Estadísticas generales correctas
- [ ] Tabla más difícil identificada
- [ ] Performance < 1 segundo

#### ✋ CHECKPOINT 6

---

### ✅ INCREMENTO 7: Panel de Admin (Opcional)
**Duración estimada:** 7 horas
**Objetivo:** Admin puede ver todos los usuarios y cambiar roles

*(Detalles omitidos por brevedad, similar estructura a incrementos anteriores)*

---

## Resumen de Estimación de Tiempo

| # | Incremento | Backend | Frontend | Testing | Total |
|---|-----------|---------|----------|---------|-------|
| 1 | Autenticación + Logins | 3h | 2h | 1h | 6h |
| 2 | Crear Sesión | 2h | 2h | 0.5h | 4.5h |
| 3 | Registrar Disparos | 3h | 3h | 1h | 7h |
| 4 | Finalizar Sesión | 2h | 2h | 0.5h | 4.5h |
| 5 | Estadísticas Básicas | 3h | 3h | 1h | 7h |
| 6 | Estadísticas Avanzadas | 4h | 3h | 1h | 8h |
| 7 | Panel Admin (opcional) | 3h | 3h | 1h | 7h |

**TOTAL SIN ADMIN:** 37 horas (5 días)
**TOTAL CON ADMIN:** 44 horas (6 días)

---

## Workflow Diario Recomendado

**Cada día:**
1. ⚙️ Desarrollar backend del incremento (2-4h)
2. ✅ Ejecutar tests automáticos backend (`php artisan test`)
3. 🎮 Desarrollar frontend del incremento (2-3h)
4. 🧪 Testing manual de integración (30min-1h)
5. 📝 Documentar progreso en bitácora
6. ✋ **CHECKPOINT:** Validar antes de avanzar

---

## Herramientas de Testing

### Backend
- **PHPUnit**: Tests automáticos
  ```bash
  php artisan test
  php artisan test --filter AuthTest
  ```
- **Postman/Insomnia**: Probar endpoints manualmente
- **Laravel Log**: `storage/logs/laravel.log`

### Frontend
- **Browser DevTools**: Network tab para ver requests
- **Console**: Verificar logs y errores
- **Vue DevTools / React DevTools**: Si se agregan después

### Base de Datos
- **phpMyAdmin**: Interfaz web
- **MySQL Workbench**: Cliente desktop
- **TablePlus**: Cliente moderno

---

## Próximos Pasos Inmediatos

1. ✅ Aprobar este plan de trabajo
2. ✅ Confirmar Laravel 11 como framework
3. ✅ Configurar entorno de desarrollo local:
   - Instalar Laravel
   - Crear base de datos
   - Configurar .env
4. ✅ Iniciar **INCREMENTO 1: Autenticación**

---

**Documento creado por:** Claude (Sonnet 4.5)
**Fecha:** 18 de octubre de 2025
**Versión:** 1.0
**Estado:** Pendiente de aprobación
