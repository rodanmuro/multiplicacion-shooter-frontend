# BitÃ¡cora 002 - 18/10/2025

## Plan de Trabajo: Backend API REST - Desarrollo Incremental

---

## Principios Fundamentales del Plan

1. âœ… **Desarrollo vertical por feature** (frontend + backend juntos)
2. âœ… **Testing manual/automÃ¡tico despuÃ©s de cada incremento**
3. âœ… **No avanzar sin validar integraciÃ³n**
4. âœ… **Despliegue continuo en ambiente de desarrollo**
5. âœ… **Cada incremento debe ser funcional y demostrable**

---

## Decisiones TÃ©cnicas

### Framework Backend: **Laravel 11**

#### JustificaciÃ³n:
- **Eloquent ORM**: Relaciones entre tablas elegantes (User â†’ GameSessions â†’ Shots)
- **Laravel Sanctum**: AutenticaciÃ³n API profesional
- **Migraciones**: Control de versiones de base de datos
- **Testing integrado**: PHPUnit para garantizar calidad
- **Ecosistema rico**: Paquetes para OAuth, estadÃ­sticas, reportes
- **Escalabilidad**: Preparado para crecimiento futuro
- **API Resources**: TransformaciÃ³n de datos JSON elegante

### LibrerÃ­a HTTP Frontend: **Axios**

#### JustificaciÃ³n:
- Interceptors para autenticaciÃ³n global
- Sintaxis mÃ¡s limpia que fetch
- Manejo de errores centralizado
- TypeScript-friendly
- ConfiguraciÃ³n de baseURL

**Comando de instalaciÃ³n:** `npm install axios`

---

## DiseÃ±o de Base de Datos

### Modelo Entidad-RelaciÃ³n

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚       users             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)                 â”‚
â”‚ google_id (UNIQUE)      â”‚
â”‚ email                   â”‚
â”‚ name                    â”‚
â”‚ picture                 â”‚
â”‚ profile (ENUM)          â”‚ â† NUEVO
â”‚ created_at              â”‚
â”‚ updated_at              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ 1
         â”‚
         â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ N                   â”‚ N
         â”‚                     â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   user_logins        â”‚  â”‚  game_sessions    â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ id (PK)              â”‚  â”‚ id (PK)           â”‚
â”‚ user_id (FK)         â”‚  â”‚ user_id (FK)      â”‚
â”‚ logged_in_at         â”‚  â”‚ started_at        â”‚
â”‚ ip_address           â”‚  â”‚ finished_at       â”‚
â”‚ user_agent           â”‚  â”‚ final_score       â”‚
â”‚ created_at           â”‚  â”‚ max_level_reached â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ duration_seconds  â”‚
                          â”‚ created_at        â”‚
                          â”‚ updated_at        â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                   â”‚ 1
                                   â”‚
                                   â”‚ N
                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                          â”‚      shots        â”‚
                          â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
                          â”‚ id (PK)           â”‚
                          â”‚ game_session_id   â”‚
                          â”‚ shot_at           â”‚
                          â”‚ coordinate_x      â”‚
                          â”‚ coordinate_y      â”‚
                          â”‚ factor_1          â”‚
                          â”‚ factor_2          â”‚
                          â”‚ correct_answer    â”‚
                          â”‚ card_value        â”‚
                          â”‚ is_correct        â”‚
                          â”‚ created_at        â”‚
                          â”‚ updated_at        â”‚
                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## DescripciÃ³n de Tablas

### Tabla: `users`
Almacena informaciÃ³n bÃ¡sica del usuario autenticado con Google OAuth.

| Campo | Tipo | DescripciÃ³n |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `google_id` | VARCHAR(255) UNIQUE | ID del usuario en Google |
| `email` | VARCHAR(255) | Email del usuario |
| `name` | VARCHAR(255) | Nombre completo |
| `picture` | TEXT | URL de la foto de perfil de Google |
| `profile` | ENUM('student', 'teacher', 'admin') | Tipo de usuario |
| `created_at` | TIMESTAMP | Fecha de registro |
| `updated_at` | TIMESTAMP | Ãšltima actualizaciÃ³n |

**Ãndices:**
- PRIMARY KEY: `id`
- UNIQUE: `google_id`
- INDEX: `email`
- INDEX: `profile`

**Valores de `profile`:**
- `student` (por defecto): Puede jugar y ver sus propias estadÃ­sticas
- `teacher`: Puede ver estadÃ­sticas de estudiantes asignados
- `admin`: Acceso total al sistema

---

### Tabla: `user_logins` â­ NUEVA
Registra cada inicio de sesiÃ³n del usuario para auditorÃ­a y anÃ¡lisis.

| Campo | Tipo | DescripciÃ³n |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `user_id` | BIGINT UNSIGNED | FK a tabla users |
| `logged_in_at` | TIMESTAMP | Timestamp del login |
| `ip_address` | VARCHAR(45) NULL | DirecciÃ³n IP (IPv4/IPv6) |
| `user_agent` | TEXT NULL | Navegador/dispositivo usado |
| `created_at` | TIMESTAMP | Fecha de creaciÃ³n del registro |

**Ãndices:**
- PRIMARY KEY: `id`
- FOREIGN KEY: `user_id` REFERENCES `users(id)` ON DELETE CASCADE
- INDEX: `user_id, logged_in_at` (para consultas de historial)

**PropÃ³sito:**
- AuditorÃ­a de accesos al sistema
- AnÃ¡lisis de frecuencia de uso
- DetecciÃ³n de patrones de uso
- Seguridad (detecciÃ³n de logins sospechosos)

---

### Tabla: `game_sessions`
Representa una sesiÃ³n de juego de 5 minutos.

| Campo | Tipo | DescripciÃ³n |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `user_id` | BIGINT UNSIGNED | FK a tabla users |
| `started_at` | TIMESTAMP | Hora de inicio de la sesiÃ³n |
| `finished_at` | TIMESTAMP NULL | Hora de finalizaciÃ³n (null si en curso) |
| `final_score` | INTEGER | Puntaje final obtenido |
| `max_level_reached` | INTEGER | Nivel mÃ¡ximo alcanzado |
| `duration_seconds` | INTEGER | DuraciÃ³n real de la sesiÃ³n |
| `created_at` | TIMESTAMP | Fecha de creaciÃ³n del registro |
| `updated_at` | TIMESTAMP | Ãšltima actualizaciÃ³n |

**Ãndices:**
- PRIMARY KEY: `id`
- FOREIGN KEY: `user_id` REFERENCES `users(id)` ON DELETE CASCADE
- INDEX: `user_id, started_at` (para consultas de historial)
- INDEX: `finished_at` (para filtrar sesiones activas/finalizadas)

---

### Tabla: `shots`
Registra cada disparo que impacta un card (correcto o incorrecto).

| Campo | Tipo | DescripciÃ³n |
|-------|------|-------------|
| `id` | BIGINT UNSIGNED | Primary key autoincremental |
| `game_session_id` | BIGINT UNSIGNED | FK a tabla game_sessions |
| `shot_at` | TIMESTAMP(3) | Timestamp con milisegundos del disparo |
| `coordinate_x` | DECIMAL(8,2) | Coordenada X del disparo (0-1200) |
| `coordinate_y` | DECIMAL(8,2) | Coordenada Y del disparo (0-800) |
| `factor_1` | INTEGER | Primer factor de la multiplicaciÃ³n |
| `factor_2` | INTEGER | Segundo factor de la multiplicaciÃ³n |
| `correct_answer` | INTEGER | Respuesta correcta de la multiplicaciÃ³n |
| `card_value` | INTEGER | Valor del card impactado |
| `is_correct` | BOOLEAN | true si acertÃ³, false si errÃ³ |
| `created_at` | TIMESTAMP | Fecha de creaciÃ³n del registro |
| `updated_at` | TIMESTAMP | Ãšltima actualizaciÃ³n |

**Ãndices:**
- PRIMARY KEY: `id`
- FOREIGN KEY: `game_session_id` REFERENCES `game_sessions(id)` ON DELETE CASCADE
- INDEX: `game_session_id` (para consultas por sesiÃ³n)
- INDEX: `is_correct` (para estadÃ­sticas de precisiÃ³n)
- INDEX: `factor_1, factor_2` (para estadÃ­sticas por tabla)

---

## Endpoints de la API

### AutenticaciÃ³n
```
POST   /api/auth/verify              - Verificar token de Google y registrar login
```

### Sesiones de Juego
```
POST   /api/sessions                 - Crear nueva sesiÃ³n de juego
PUT    /api/sessions/{id}/finish     - Finalizar sesiÃ³n y guardar puntaje
GET    /api/sessions                 - Listar sesiones del usuario (paginado)
GET    /api/sessions/{id}            - Detalle de sesiÃ³n especÃ­fica + disparos
```

### Disparos
```
POST   /api/sessions/{id}/shots      - Registrar disparo que impacta card
```

### EstadÃ­sticas
```
GET    /api/stats/user               - EstadÃ­sticas generales del usuario
GET    /api/stats/tables             - DesempeÃ±o por tabla de multiplicar
GET    /api/stats/progress           - Progreso histÃ³rico (Ãºltimas 10 sesiones)
```

### AdministraciÃ³n (solo admin)
```
GET    /api/admin/users              - Listar todos los usuarios
PUT    /api/admin/users/{id}/profile - Cambiar rol de usuario
GET    /api/admin/stats/global       - EstadÃ­sticas globales del sistema
```

---

## Incrementos de Desarrollo

### âœ… INCREMENTO 1: AutenticaciÃ³n Completa
**DuraciÃ³n estimada:** 6 horas
**Objetivo:** Usuario puede loguearse con Google OAuth y quedar registrado en la base de datos

#### Backend (2-3 horas)

**Setup inicial:**
- Crear proyecto Laravel 11 en el directorio `multiplicacion-shooter-backend`
- Instalar dependencia `google/apiclient` para verificaciÃ³n de tokens JWT de Google

**Tareas de configuraciÃ³n:**

1. **Configurar variables de entorno (.env):**
   - Configurar conexiÃ³n a MySQL (host, puerto, nombre de BD, credenciales)
   - Agregar `GOOGLE_CLIENT_ID` para validaciÃ³n de tokens

2. **Configurar CORS:**
   - Modificar archivo `config/cors.php` para permitir peticiones desde frontend (localhost:5173)
   - Habilitar credenciales y todos los mÃ©todos HTTP necesarios
   - Exponer rutas `/api/*`

3. **Crear estructura de base de datos:**
   - Generar migraciÃ³n para tabla `users` con campos: google_id (Ãºnico), email, name, picture, profile (enum)
   - Generar migraciÃ³n para tabla `user_logins` con campos: user_id (FK), logged_in_at, ip_address, user_agent
   - Ejecutar migraciones para crear tablas

4. **Crear modelos Eloquent:**
   - **Modelo User:** Definir campos fillable, relaciÃ³n hasMany con UserLogin, constantes para tipos de perfil (STUDENT, TEACHER, ADMIN), mÃ©todo helper `isAdmin()`
   - **Modelo UserLogin:** Definir campos fillable, casting de fecha para logged_in_at, relaciÃ³n belongsTo con User

5. **Crear servicio de autenticaciÃ³n:**
   - Generar clase `GoogleAuthService` para encapsular lÃ³gica de verificaciÃ³n de tokens
   - Implementar mÃ©todo para validar token JWT con librerÃ­a de Google
   - Extraer informaciÃ³n del usuario (sub, email, name, picture) del payload del token

6. **Crear controlador de autenticaciÃ³n:**
   - Generar `AuthController` con mÃ©todo `verify`
   - Validar que el request contenga campo `token` obligatorio
   - Invocar servicio de Google para verificar el token
   - Buscar usuario existente por `google_id` o crear uno nuevo con perfil 'student' por defecto
   - **SIEMPRE** crear registro en `user_logins` con timestamp actual, IP del cliente y user agent
   - Retornar respuesta JSON con Ã©xito y datos del usuario

7. **Definir ruta API:**
   - Registrar endpoint `POST /api/auth/verify` en `routes/api.php`

#### Frontend (2 horas)

**Tareas:**

1. **Instalar Axios:**
   - Ejecutar `npm install axios` en el directorio del frontend

2. **Crear configuraciÃ³n de API:**
   - Crear archivo `src/config/api.ts` con constantes: BASE_URL (usando variable de entorno VITE_API_URL o fallback), TIMEOUT

3. **Crear cliente Axios base:**
   - Crear `src/services/apiService.ts` con instancia de Axios configurada
   - Implementar interceptor de request para agregar token JWT en header `Authorization: Bearer {token}` (obtenido de localStorage)
   - Implementar interceptor de response para manejar errores 401 (token invÃ¡lido/expirado)

4. **Crear tipos TypeScript:**
   - Definir interface `ApiResponse<T>` genÃ©rica con campos success y data
   - Definir interface `UserData` con campos del usuario (id, google_id, email, name, picture, profile, created_at)

5. **Crear servicio de autenticaciÃ³n:**
   - Crear `src/services/authApiService.ts` con mÃ©todo `verifyGoogleToken(token: string)`
   - MÃ©todo debe hacer POST al endpoint `/auth/verify` y retornar los datos del usuario

6. **Integrar con LoginScene:**
   - Modificar mÃ©todo `handleGoogleCallback` en `LoginScene.ts`
   - DespuÃ©s de procesar login localmente con `AuthManager`, enviar token al backend
   - Guardar `profile` del usuario en localStorage para uso futuro
   - Manejar errores de conexiÃ³n con mensaje amigable al usuario
   - Transicionar a GameScene despuÃ©s de login exitoso

7. **Actualizar variables de entorno:**
   - Agregar `VITE_API_URL=http://localhost:8000/api` al archivo `.env` del frontend

#### Testing Manual (30 minutos)

**Checklist de validaciÃ³n:**

- [ ] **Primera vez que usuario se loguea:**
  - [ ] Se crea registro en tabla `users` con `profile='student'`
  - [ ] Se crea registro en tabla `user_logins` con timestamp actual
  - [ ] Frontend recibe datos del usuario correctamente
  - [ ] Console muestra: "Usuario registrado en backend: {datos}"

- [ ] **Segunda vez que usuario se loguea (mismo google_id):**
  - [ ] NO se duplica en tabla `users`
  - [ ] SÃ se crea nuevo registro en tabla `user_logins`
  - [ ] Frontend recibe los mismos datos del usuario
  - [ ] `ip_address` y `user_agent` se guardan correctamente

- [ ] **Verificar en base de datos:**
  - [ ] Abrir phpMyAdmin/MySQL Workbench
  - [ ] Ver tabla `users`: debe haber 1 registro
  - [ ] Ver tabla `user_logins`: debe haber N registros (uno por cada login)
  - [ ] Verificar que `user_id` en `user_logins` coincide con `id` en `users`

- [ ] **Manejo de errores:**
  - [ ] Detener servidor Laravel â†’ Frontend muestra mensaje de error
  - [ ] Token invÃ¡lido â†’ Backend retorna 401/400

#### Testing AutomÃ¡tico

**Crear suite de tests en Laravel:**
- Generar `tests/Feature/AuthTest.php` con PHPUnit
- Implementar tests para:
  1. Primer login crea usuario y registro de login
  2. Segundo login NO duplica usuario pero SÃ crea registro de login
  3. MÃºltiples logins crean mÃºltiples registros en `user_logins`
- Ejecutar tests con `php artisan test --filter AuthTest`

#### âœ‹ CHECKPOINT 1

**NO AVANZAR AL INCREMENTO 2 SIN VALIDAR:**
- âœ… Todos los tests automÃ¡ticos pasan
- âœ… Todos los checks del testing manual estÃ¡n completados
- âœ… Base de datos tiene los registros esperados
- âœ… Frontend muestra datos correctamente en consola

---

### âœ… INCREMENTO 2: Crear SesiÃ³n de Juego
**DuraciÃ³n estimada:** 4.5 horas
**Objetivo:** Al iniciar el juego, crear una sesiÃ³n en la base de datos

#### Backend (2 horas)

**Tareas:**

1. **Crear migraciÃ³n de game_sessions:**
   - Generar migraciÃ³n con comando artisan
   - Definir campos: user_id (FK), started_at, finished_at (nullable), final_score, max_level_reached, duration_seconds
   - Agregar Ã­ndices para optimizar consultas: (user_id, started_at) y finished_at
   - Ejecutar migraciÃ³n

2. **Crear modelo GameSession:**
   - Definir campos fillable
   - Configurar casting de timestamps para started_at y finished_at
   - Implementar relaciÃ³n belongsTo con User
   - Implementar relaciÃ³n hasMany con Shot (para futuro incremento)
   - Agregar mÃ©todo helper `isActive()` que verifica si finished_at es null

3. **Actualizar modelo User:**
   - Agregar relaciÃ³n hasMany con GameSession

4. **Crear middleware de autenticaciÃ³n:**
   - Generar `ValidateGoogleToken` middleware
   - Extraer token del header `Authorization: Bearer`
   - Verificar token con servicio de Google
   - Buscar usuario en BD por google_id del token
   - Agregar usuario autenticado al request para uso en controladores
   - Retornar error 401 si token invÃ¡lido o usuario no existe

5. **Registrar middleware:**
   - Agregar alias `auth.google` para el middleware en `bootstrap/app.php`

6. **Crear request de validaciÃ³n:**
   - Generar `CreateSessionRequest`
   - Definir regla: campo `started_at` es requerido y debe ser fecha vÃ¡lida

7. **Crear controlador de sesiones:**
   - Generar `GameSessionController`
   - Implementar mÃ©todo `store` que:
     - Obtiene usuario autenticado del request
     - Crea registro de GameSession con user_id y started_at
     - Retorna respuesta JSON con status 201 y datos de la sesiÃ³n creada

8. **Definir ruta protegida:**
   - Registrar `POST /api/sessions` dentro de grupo con middleware `auth.google`

#### Frontend (2 horas)

**Tareas:**

1. **Crear tipos TypeScript:**
   - Agregar interface `GameSessionData` en `src/types/api.ts` con todos los campos de una sesiÃ³n

2. **Crear servicio de sesiones:**
   - Crear `src/services/sessionApiService.ts`
   - Implementar mÃ©todo `createSession(startedAt: string)` que hace POST a `/sessions`

3. **Modificar GameScene:**
   - Agregar propiedad privada `sessionId: number | null` a la clase
   - En mÃ©todo `create()`, llamar servicio para crear sesiÃ³n en backend
   - Pasar timestamp actual en formato ISO
   - Almacenar `sessionId` retornado para uso posterior
   - Si falla la creaciÃ³n, mostrar mensaje de error al usuario pero permitir continuar jugando
   - Loguear en console el ID de sesiÃ³n creado

#### Testing Manual (30 minutos)

**Checklist de validaciÃ³n:**

- [ ] **Al iniciar el juego:**
  - [ ] Console muestra: "SesiÃ³n de juego creada: {id}"
  - [ ] Se crea registro en tabla `game_sessions`
  - [ ] `user_id` corresponde al usuario logueado
  - [ ] `started_at` tiene timestamp actual
  - [ ] `finished_at` es NULL
  - [ ] `final_score` es 0
  - [ ] `max_level_reached` es 1

- [ ] **MÃºltiples inicios de juego:**
  - [ ] Cada inicio crea nueva sesiÃ³n
  - [ ] IDs son secuenciales
  - [ ] Todas las sesiones pertenecen al usuario correcto

- [ ] **Usuario no autenticado:**
  - [ ] Si no hay token â†’ error 401
  - [ ] Frontend maneja el error apropiadamente

- [ ] **Verificar en base de datos:**
  - [ ] phpMyAdmin/Workbench â†’ tabla `game_sessions`
  - [ ] Verificar relaciÃ³n con `users`

#### Testing AutomÃ¡tico

**Crear tests:**
- Generar `tests/Feature/GameSessionTest.php`
- Implementar tests para:
  1. Usuario autenticado puede crear sesiÃ³n
  2. Usuario no autenticado NO puede crear sesiÃ³n (recibe 401)
  3. SesiÃ³n creada pertenece al usuario correcto
- Ejecutar con `php artisan test --filter GameSessionTest`

#### âœ‹ CHECKPOINT 2

**NO AVANZAR AL INCREMENTO 3 SIN VALIDAR:**
- âœ… Todos los tests automÃ¡ticos pasan
- âœ… SesiÃ³n se crea correctamente en BD
- âœ… Frontend recibe y almacena sessionId
- âœ… Console muestra sessionId claramente

---

### âœ… INCREMENTO 3: Registrar Disparos
**DuraciÃ³n estimada:** 7 horas
**Objetivo:** Cada disparo que impacta un card queda registrado en la base de datos

#### Backend (2-3 horas)

**Tareas:**

1. **Crear migraciÃ³n de shots:**
   - Generar migraciÃ³n con campos: game_session_id (FK), shot_at (timestamp con precisiÃ³n de milisegundos), coordinate_x, coordinate_y (decimales), factor_1, factor_2, correct_answer, card_value, is_correct (booleano)
   - Agregar Ã­ndices: game_session_id, is_correct, (factor_1, factor_2)
   - Ejecutar migraciÃ³n

2. **Crear modelo Shot:**
   - Definir fillable con todos los campos
   - Configurar castings: shot_at como datetime, is_correct como boolean, coordenadas como float
   - Implementar relaciÃ³n belongsTo con GameSession

3. **Crear request de validaciÃ³n:**
   - Generar `RecordShotRequest`
   - Definir reglas: todos los campos requeridos con sus tipos y rangos apropiados (ej: coordenadas entre 0-1200/0-800, factores entre 1-12)

4. **Crear controlador de disparos:**
   - Generar `ShotController`
   - Implementar mÃ©todo `store` que:
     - Recibe sessionId como parÃ¡metro de ruta
     - Busca la sesiÃ³n en BD
     - Valida que la sesiÃ³n existe (404 si no)
     - Valida que la sesiÃ³n pertenece al usuario autenticado (403 si no)
     - Valida que la sesiÃ³n estÃ¡ activa usando `isActive()` (400 si finalizÃ³)
     - Crea registro de Shot con todos los datos del disparo
     - Retorna respuesta JSON con status 201 y datos del disparo

5. **Definir ruta protegida:**
   - Registrar `POST /api/sessions/{id}/shots` dentro de grupo con middleware `auth.google`

#### Frontend (3 horas)

**Tareas:**

1. **Crear tipos TypeScript:**
   - Agregar interface `ShotData` con campos de respuesta
   - Agregar interface `RecordShotPayload` con campos de request

2. **Crear servicio de disparos:**
   - Crear `src/services/shotApiService.ts`
   - Implementar mÃ©todo `recordShot(sessionId, shotData)` que hace POST a `/sessions/{id}/shots`

3. **Modificar GameScene:**
   - Importar servicio de disparos
   - Modificar mÃ©todo `onShoot()` para que SOLO si impacta un card:
     - Registre el disparo en backend de forma asÃ­ncrona
     - EnvÃ­e todos los datos: timestamp, coordenadas, factores, respuesta correcta, valor del card, si es correcto
     - Capture errores sin interrumpir el juego
     - Loguee en console confirmaciÃ³n de registro

4. **Actualizar QuestionGenerator:**
   - Agregar propiedad privada `currentQuestion` para almacenar pregunta actual
   - Modificar `generateQuestion()` para guardar la pregunta generada
   - Agregar mÃ©todo pÃºblico `getCurrentQuestion()` para que GameScene pueda acceder a los factores y respuesta

#### Testing Manual (1 hora)

**Checklist de validaciÃ³n:**

- [ ] **Disparo correcto a card:**
  - [ ] Se crea registro en tabla `shots`
  - [ ] `is_correct` es `true`
  - [ ] `card_value` = `correct_answer`
  - [ ] Coordenadas X, Y correctas
  - [ ] `factor_1`, `factor_2`, `correct_answer` correctos
  - [ ] Console muestra: "Disparo registrado en backend"

- [ ] **Disparo incorrecto a card:**
  - [ ] Se crea registro en tabla `shots`
  - [ ] `is_correct` es `false`
  - [ ] `card_value` â‰  `correct_answer`
  - [ ] Resto de datos correctos

- [ ] **Disparo al aire (sin impactar card):**
  - [ ] NO se crea registro en tabla `shots`
  - [ ] Juego continÃºa normal

- [ ] **MÃºltiples disparos en una sesiÃ³n:**
  - [ ] Todos tienen el mismo `game_session_id`
  - [ ] Timestamps son secuenciales
  - [ ] Contador de registros aumenta correctamente

- [ ] **SesiÃ³n finalizada:**
  - [ ] Si intentamos registrar disparo â†’ error 400
  - [ ] Frontend maneja el error sin romper el juego

- [ ] **SesiÃ³n de otro usuario:**
  - [ ] No se puede registrar disparo â†’ error 403

- [ ] **Verificar en base de datos:**
  - [ ] Ver tabla `shots`
  - [ ] Verificar relaciÃ³n con `game_sessions`
  - [ ] Timestamp con precisiÃ³n de milisegundos

#### Testing AutomÃ¡tico

**Crear tests:**
- Generar `tests/Feature/ShotTest.php`
- Implementar tests para:
  1. Puede registrar disparo correcto
  2. Puede registrar disparo incorrecto
  3. NO puede registrar disparo en sesiÃ³n finalizada (400)
  4. NO puede registrar disparo en sesiÃ³n de otro usuario (403)
- Ejecutar con `php artisan test --filter ShotTest`

#### âœ‹ CHECKPOINT 3

**NO AVANZAR AL INCREMENTO 4 SIN VALIDAR:**
- âœ… Todos los tests automÃ¡ticos pasan
- âœ… Disparos correctos e incorrectos se registran
- âœ… Disparos al aire NO se registran
- âœ… Validaciones de seguridad funcionan (sesiÃ³n finalizada, otro usuario)
- âœ… Console muestra confirmaciÃ³n de registro

---

### âœ… INCREMENTO 4: Finalizar SesiÃ³n
**DuraciÃ³n estimada:** 4.5 horas
**Objetivo:** Al terminar la sesiÃ³n de 5 minutos, guardar el puntaje final y estadÃ­sticas

#### Backend (2 horas)

**Tareas:**

1. **Crear request de validaciÃ³n:**
   - Generar `FinishSessionRequest`
   - Definir reglas: finished_at (fecha), final_score (entero â‰¥0), max_level_reached (entero â‰¥1), duration_seconds (entero 0-600)

2. **Implementar mÃ©todo finish en GameSessionController:**
   - Recibir sessionId como parÃ¡metro de ruta
   - Buscar sesiÃ³n en BD
   - Validar que existe (404 si no)
   - Validar que pertenece al usuario autenticado (403 si no)
   - Validar que estÃ¡ activa usando `isActive()` (400 si ya finalizÃ³)
   - Actualizar campos: finished_at, final_score, max_level_reached, duration_seconds
   - Calcular estadÃ­sticas automÃ¡ticamente: total_shots, correct_shots, wrong_shots, accuracy (consultando tabla shots)
   - Retornar respuesta JSON con datos actualizados + estadÃ­sticas calculadas

3. **Definir ruta protegida:**
   - Registrar `PUT /api/sessions/{id}/finish` dentro de grupo con middleware `auth.google`

#### Frontend (2 horas)

**Tareas:**

1. **Crear tipos TypeScript:**
   - Agregar interface `FinishSessionPayload` con campos del request
   - Agregar interface `FinishedSessionData` extendiendo `GameSessionData` con campos adicionales de estadÃ­sticas

2. **Actualizar servicio de sesiones:**
   - Agregar mÃ©todo `finishSession(sessionId, finishData)` que hace PUT a `/sessions/{id}/finish`

3. **Modificar GameScene:**
   - Modificar mÃ©todo `endSession()` para:
     - Detener spawn de tarjetas y cancelar timers
     - Si existe sessionId, llamar servicio para finalizar sesiÃ³n
     - Enviar: timestamp actual, puntaje final, nivel mÃ¡ximo alcanzado, duraciÃ³n en segundos
     - Con datos del backend, mostrar pantalla de resumen con estadÃ­sticas
     - Si falla backend, mostrar resumen con datos locales como fallback
     - Loguear en console datos de sesiÃ³n finalizada

4. **Crear mÃ©todo de pantalla de resumen:**
   - Crear `showSessionSummary(sessionData)` que usa datos del backend
   - Mostrar overlay oscuro
   - Mostrar estadÃ­sticas: puntaje, nivel, tabla actual, disparos totales, aciertos/errores, precisiÃ³n, tiempo
   - Agregar botÃ³n para reiniciar juego
   - Crear mÃ©todo alternativo `showSessionSummaryLocal()` para fallback con datos locales

#### Testing Manual (30 minutos)

**Checklist de validaciÃ³n:**

- [ ] **Al finalizar sesiÃ³n (5 minutos):**
  - [ ] `finished_at` actualizado en tabla `game_sessions`
  - [ ] `final_score` correcto
  - [ ] `max_level_reached` correcto
  - [ ] `duration_seconds` â‰ˆ 300 segundos
  - [ ] Console muestra: "SesiÃ³n finalizada en backend: {datos}"

- [ ] **Pantalla de resumen:**
  - [ ] Muestra datos del backend (no locales)
  - [ ] Total de disparos correcto
  - [ ] Aciertos y errores correctos
  - [ ] PrecisiÃ³n calculada correctamente
  - [ ] Tiempo mostrado en formato MM:SS

- [ ] **Intentar finalizar sesiÃ³n ya finalizada:**
  - [ ] Backend retorna error 400
  - [ ] Frontend maneja el error

- [ ] **Intentar registrar disparo despuÃ©s de finalizar:**
  - [ ] Backend retorna error 400
  - [ ] No se crea registro en tabla `shots`

- [ ] **Verificar en base de datos:**
  - [ ] `finished_at` NO es NULL
  - [ ] Todos los campos actualizados
  - [ ] SesiÃ³n marcada como inactiva

#### Testing AutomÃ¡tico

**Crear tests:**
- Generar `tests/Feature/FinishSessionTest.php`
- Implementar tests para:
  1. Puede finalizar sesiÃ³n con datos correctos
  2. NO puede finalizar sesiÃ³n ya finalizada (400)
  3. NO puede finalizar sesiÃ³n de otro usuario (403)
  4. Calcula precisiÃ³n correctamente (crear shots de prueba y verificar cÃ¡lculo)
- Ejecutar con `php artisan test --filter FinishSessionTest`

#### âœ‹ CHECKPOINT 4

**NO AVANZAR AL INCREMENTO 5 SIN VALIDAR:**
- âœ… Todos los tests automÃ¡ticos pasan
- âœ… SesiÃ³n se finaliza correctamente
- âœ… EstadÃ­sticas calculadas automÃ¡ticamente
- âœ… Pantalla de resumen muestra datos del backend
- âœ… No se pueden registrar disparos despuÃ©s de finalizar

---

### âœ… INCREMENTO 5: EstadÃ­sticas BÃ¡sicas
**DuraciÃ³n estimada:** 7 horas
**Objetivo:** Ver historial de sesiones del usuario autenticado

#### Backend (3 horas)

**Tareas:**

1. **Crear API Resources:**
   - Generar `GameSessionResource` y `ShotResource`
   - En GameSessionResource:
     - Definir transformaciÃ³n de datos de sesiÃ³n
     - Incluir campos calculados: total_shots, correct_shots, accuracy (consultando relaciÃ³n shots)
     - Implementar mÃ©todo privado `calculateAccuracy()` para reutilizaciÃ³n
   - En ShotResource:
     - Definir transformaciÃ³n de datos de disparo con campos relevantes

2. **Implementar mÃ©todo index en GameSessionController:**
   - Obtener usuario autenticado
   - Consultar sesiones del usuario ordenadas por started_at descendente
   - Paginar resultados (10 por pÃ¡gina)
   - Retornar colecciÃ³n usando GameSessionResource

3. **Implementar mÃ©todo show en GameSessionController:**
   - Recibir sessionId como parÃ¡metro
   - Consultar sesiÃ³n con eager loading de shots
   - Validar que pertenece al usuario autenticado (404 si no existe o no es suya)
   - Retornar respuesta JSON con session (usando Resource) y shots (colecciÃ³n usando Resource)

4. **Definir rutas protegidas:**
   - Registrar `GET /api/sessions` para listado
   - Registrar `GET /api/sessions/{id}` para detalle

#### Frontend (3 horas)

**Tareas:**

1. **Crear tipos TypeScript:**
   - Agregar interface `SessionListItem` con campos de sesiÃ³n + estadÃ­sticas calculadas
   - Agregar interface `SessionDetail` con session y array de shots

2. **Actualizar servicio de sesiones:**
   - Agregar mÃ©todo `getSessions(page)` que hace GET a `/sessions?page={page}`
   - Agregar mÃ©todo `getSessionDetail(sessionId)` que hace GET a `/sessions/{id}`

3. **Crear nueva escena de estadÃ­sticas:**
   - Crear archivo `src/scenes/StatsScene.ts`
   - Implementar scene con:
     - Fondo y tÃ­tulo "HISTORIAL DE SESIONES"
     - BotÃ³n para volver al juego
     - MÃ©todo `loadSessions()` que carga sesiones del backend
     - MÃ©todo `displaySessions()` que renderiza lista de sesiones con datos resumidos (fecha, hora, puntaje, nivel, precisiÃ³n, disparos)
     - Hacer cada sesiÃ³n clickeable para ver detalle
     - MÃ©todo `showSessionDetail(sessionId)` que carga y muestra modal con informaciÃ³n completa
     - MÃ©todo `showDetailModal(detail)` que renderiza overlay con estadÃ­sticas detalladas y lista de disparos
     - Manejar errores de carga con mensajes apropiados

4. **Registrar escena:**
   - Agregar `StatsScene` al array de scenes en `gameConfig.ts`

5. **Agregar navegaciÃ³n:**
   - En GameScene, agregar botÃ³n "Ver EstadÃ­sticas" que transiciona a StatsScene

#### Testing Manual (1 hora)

**Checklist de validaciÃ³n:**

- [ ] **Listado de sesiones:**
  - [ ] Se muestran todas las sesiones del usuario
  - [ ] Orden descendente (mÃ¡s reciente primero)
  - [ ] Datos mostrados correctamente
  - [ ] PaginaciÃ³n funciona (si hay mÃ¡s de 10)

- [ ] **Detalle de sesiÃ³n:**
  - [ ] Click en sesiÃ³n abre modal
  - [ ] Muestra todos los datos
  - [ ] Cantidad de disparos correcta
  - [ ] BotÃ³n cerrar funciona

- [ ] **Performance:**
  - [ ] Lista carga en < 1 segundo
  - [ ] Detalle carga en < 500ms

- [ ] **Seguridad:**
  - [ ] Solo se muestran sesiones del usuario autenticado
  - [ ] No se pueden ver sesiones de otros usuarios

#### Testing AutomÃ¡tico

**Crear tests:**
- Implementar tests para:
  1. Usuario puede ver sus propias sesiones
  2. Usuario NO puede ver sesiones de otros usuarios
- Ejecutar tests

#### âœ‹ CHECKPOINT 5

**NO AVANZAR AL INCREMENTO 6 SIN VALIDAR:**
- âœ… Listado de sesiones funciona
- âœ… Detalle de sesiÃ³n muestra disparos
- âœ… Solo se muestran datos del usuario autenticado
- âœ… Performance aceptable

---

### âœ… INCREMENTO 6: EstadÃ­sticas Avanzadas
**DuraciÃ³n estimada:** 8 horas
**Objetivo:** AnÃ¡lisis de desempeÃ±o por tabla de multiplicar

#### Backend (4 horas)

**Tareas:**

1. **Crear servicio de estadÃ­sticas:**
   - Generar clase `StatsService` para encapsular lÃ³gica de cÃ¡lculos complejos
   - Implementar mÃ©todo `getUserStats(user)` que:
     - Consulta todas las sesiones del usuario
     - Calcula estadÃ­sticas globales: total_sessions, total_shots, total_correct, total_wrong, overall_accuracy, average_score, best_score, total_playtime_minutes
     - Retorna array asociativo con todas las mÃ©tricas

2. **Implementar anÃ¡lisis por tabla:**
   - En StatsService, agregar mÃ©todo `getTableStats(user)` que:
     - Para cada tabla del 1 al 10:
       - Consulta shots donde factor_1 o factor_2 sea igual a la tabla
       - Cuenta total de intentos, aciertos y errores
       - Calcula precisiÃ³n porcentual
     - Ordena tablas por precisiÃ³n ascendente (identificar tablas mÃ¡s difÃ­ciles)
     - Retorna array de estadÃ­sticas por tabla

3. **Implementar historial de progreso:**
   - En StatsService, agregar mÃ©todo `getProgressHistory(user, limit)` que:
     - Consulta Ãºltimas N sesiones finalizadas del usuario
     - Para cada sesiÃ³n calcula accuracy
     - Retorna array ordenado cronolÃ³gicamente (mÃ¡s antiguo primero) para graficar evoluciÃ³n

4. **Crear controlador de estadÃ­sticas:**
   - Generar `StatsController` con inyecciÃ³n de dependencia de StatsService
   - Implementar mÃ©todo `userStats` que retorna estadÃ­sticas generales
   - Implementar mÃ©todo `tableStats` que retorna anÃ¡lisis por tabla
   - Implementar mÃ©todo `progress` que retorna historial (con parÃ¡metro opcional limit)

5. **Definir rutas protegidas:**
   - Registrar `GET /api/stats/user`
   - Registrar `GET /api/stats/tables`
   - Registrar `GET /api/stats/progress`

#### Frontend (3 horas)

**Tareas:**

1. **Crear tipos TypeScript:**
   - Agregar interface `UserStats` con todas las mÃ©tricas globales
   - Agregar interface `TableStat` con datos por tabla (table, total_attempts, correct_attempts, wrong_attempts, accuracy)

2. **Crear servicio de estadÃ­sticas:**
   - Crear `src/services/statsApiService.ts`
   - Implementar mÃ©todo `getUserStats()` que hace GET a `/stats/user`
   - Implementar mÃ©todo `getTableStats()` que hace GET a `/stats/tables`

3. **Actualizar StatsScene:**
   - Agregar mÃ©todo `loadAdvancedStats()` que:
     - Carga estadÃ­sticas generales y por tabla en paralelo
     - Invoca mÃ©todos de renderizado con datos obtenidos
   - Implementar mÃ©todo `displayUserStats(stats)` que:
     - Renderiza texto con todas las mÃ©tricas globales formateadas
   - Implementar mÃ©todo `displayTableStats(stats)` que:
     - Renderiza lista de tablas con precisiÃ³n
     - Usa color verde para tablas con >70% precisiÃ³n, rojo para <70%
     - Resalta la tabla mÃ¡s difÃ­cil con icono de advertencia
   - Manejar errores de carga

#### Testing Manual (1 hora)

**Checklist:**
- [ ] EstadÃ­sticas generales correctas
- [ ] Tabla mÃ¡s difÃ­cil identificada
- [ ] Performance < 1 segundo
- [ ] Colores apropiados por precisiÃ³n

#### âœ‹ CHECKPOINT 6

**NO AVANZAR AL INCREMENTO 7 SIN VALIDAR:**
- âœ… EstadÃ­sticas globales se calculan correctamente
- âœ… AnÃ¡lisis por tabla funciona
- âœ… Tabla mÃ¡s difÃ­cil se identifica correctamente
- âœ… Performance aceptable

---

### âœ… INCREMENTO 7: Panel de Admin (Opcional)
**DuraciÃ³n estimada:** 7 horas
**Objetivo:** Admin puede ver todos los usuarios y cambiar roles

#### Backend (3 horas)

**DescripciÃ³n general:**
- Crear middleware `RequireAdmin` que valida que el usuario autenticado tiene `profile='admin'`
- Crear `AdminController` con mÃ©todos para:
  - Listar todos los usuarios con paginaciÃ³n y bÃºsqueda
  - Cambiar rol/perfil de un usuario
  - Ver estadÃ­sticas globales del sistema (total usuarios, sesiones, disparos, tablas mÃ¡s practicadas)
- Definir rutas bajo `/api/admin/*` protegidas con middleware de admin
- Crear tests para verificar que solo admins pueden acceder

#### Frontend (3 horas)

**DescripciÃ³n general:**
- Crear `AdminScene` con:
  - Listado de usuarios con filtros
  - Modal para cambiar perfil de usuario
  - Panel de estadÃ­sticas globales
  - GrÃ¡ficos de uso del sistema
- Agregar botÃ³n "Panel Admin" en GameScene solo visible para usuarios con `profile='admin'`
- Implementar confirmaciones para acciones sensibles

#### Testing (1 hora)

**DescripciÃ³n general:**
- Validar que usuarios no-admin no pueden acceder a endpoints de admin (403)
- Validar que admin puede cambiar roles correctamente
- Validar que estadÃ­sticas globales se calculan bien

---

## Resumen de EstimaciÃ³n de Tiempo

| # | Incremento | Backend | Frontend | Testing | Total |
|---|-----------|---------|----------|---------|-------|
| 1 | AutenticaciÃ³n + Logins | 3h | 2h | 1h | 6h |
| 2 | Crear SesiÃ³n | 2h | 2h | 0.5h | 4.5h |
| 3 | Registrar Disparos | 3h | 3h | 1h | 7h |
| 4 | Finalizar SesiÃ³n | 2h | 2h | 0.5h | 4.5h |
| 5 | EstadÃ­sticas BÃ¡sicas | 3h | 3h | 1h | 7h |
| 6 | EstadÃ­sticas Avanzadas | 4h | 3h | 1h | 8h |
| 7 | Panel Admin (opcional) | 3h | 3h | 1h | 7h |

**TOTAL SIN ADMIN:** 37 horas (â‰ˆ 5 dÃ­as laborales)
**TOTAL CON ADMIN:** 44 horas (â‰ˆ 6 dÃ­as laborales)

---

## Workflow Diario Recomendado

**Cada dÃ­a:**
1. âš™ï¸ Desarrollar backend del incremento (2-4h)
2. âœ… Ejecutar tests automÃ¡ticos backend (`php artisan test`)
3. ğŸ® Desarrollar frontend del incremento (2-3h)
4. ğŸ§ª Testing manual de integraciÃ³n (30min-1h)
5. ğŸ“ Documentar progreso en bitÃ¡cora
6. âœ‹ **CHECKPOINT:** Validar antes de avanzar

---

## Herramientas de Testing

### Backend
- **PHPUnit**: Tests automÃ¡ticos
  - `php artisan test` (todos los tests)
  - `php artisan test --filter AuthTest` (test especÃ­fico)
- **Postman/Insomnia**: Probar endpoints manualmente
- **Laravel Log**: `storage/logs/laravel.log` para debugging

### Frontend
- **Browser DevTools**: Network tab para ver requests/responses
- **Console**: Verificar logs y errores JavaScript
- **Vue DevTools / React DevTools**: Si se agregan despuÃ©s

### Base de Datos
- **phpMyAdmin**: Interfaz web para MySQL
- **MySQL Workbench**: Cliente desktop profesional
- **TablePlus**: Cliente moderno multiplataforma

---

## PrÃ³ximos Pasos Inmediatos

1. âœ… Aprobar este plan de trabajo
2. âœ… Confirmar Laravel 11 como framework backend
3. âœ… Configurar entorno de desarrollo local:
   - Instalar PHP 8.2+, Composer, MySQL
   - Crear proyecto Laravel 11
   - Crear base de datos `multiplication_shooter`
   - Configurar archivo `.env` con credenciales
4. âœ… Iniciar **INCREMENTO 1: AutenticaciÃ³n**

---

**Documento creado por:** Claude (Sonnet 4.5)
**Fecha:** 18 de octubre de 2025
**VersiÃ³n:** 2.0
**Estado:** Listo para implementaciÃ³n

**Changelog v2.0:**
- âœ… Transformado de tutorial con cÃ³digo a documento de planeaciÃ³n
- âœ… Reemplazados bloques de cÃ³digo por descripciones detalladas
- âœ… Mantenida estructura de incrementos y checkpoints
- âœ… Conservadas justificaciones tÃ©cnicas y objetivos
